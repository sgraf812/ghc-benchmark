diff --git a/compiler/basicTypes/Demand.hs b/compiler/basicTypes/Demand.hs
--- a/compiler/basicTypes/Demand.hs
+++ b/compiler/basicTypes/Demand.hs
@@ -11,45 +11,50 @@
         StrDmd, UseDmd(..), Count,
 
         Demand, CleanDemand, getStrDmd, getUseDmd,
-        mkProdDmd, mkOnceUsedDmd, mkManyUsedDmd, mkHeadStrict, oneifyDmd,
+        mkProdDmd, mkOnceUsedDmd, mkManyUsedDmd, mkNeverUsedDmd,
+        mkHeadStrict, oneifyDmd,
         toCleanDmd,
-        absDmd, topDmd, botDmd, seqDmd,
+        absDmd, topDmd, botDmd, seqDmd, strictFieldDmd,
         lubDmd, bothDmd,
         lazyApply1Dmd, lazyApply2Dmd, strictApply1Dmd,
         catchArgDmd,
         isTopDmd, isAbsDmd, isSeqDmd,
         peelUseCall, cleanUseDmd_maybe, strictenDmd, bothCleanDmd,
         addCaseBndrDmd,
 
-        DmdType(..), dmdTypeDepth, lubDmdType, bothDmdType,
-        nopDmdType, botDmdType, mkDmdType,
+        DmdType(..), dmdTypeDepth, lubDmdType, lubDmdTypes, bothDmdType,
+        nopDmdType, litDmdType, botDmdType, mkDmdType, cprProdDmdType, cprSumDmdType,
         addDemand, removeDmdTyArgs,
         BothDmdArg, mkBothDmdArg, toBothDmdArg,
 
         DmdEnv, emptyDmdEnv,
         peelFV, findIdDemand,
 
         DmdResult, CPRResult,
-        isBotRes, isTopRes,
-        topRes, botRes, exnRes, cprProdRes,
-        vanillaCprProdRes, cprSumRes,
+        isBotRes, isTopRes, getDmdResult, resTypeArgDmd,
+        topRes, convRes, botRes, exnRes,
+        cprProdRes, cprProdRes',
+        splitNestedRes,
         appIsBottom, isBottomingSig, pprIfaceStrictSig,
-        trimCPRInfo, returnsCPR_maybe,
+        returnsCPR_maybe,
+        forgetCPR, forgetSumCPR, forgetLazyCPR,
         StrictSig(..), mkStrictSig, mkClosedStrictSig,
-        nopSig, botSig, exnSig, cprProdSig,
+        nopSig, botSig, exnSig, cprProdSig, convergeSig,
         isTopSig, hasDemandEnvSig,
         splitStrictSig, strictSigDmdEnv,
         increaseStrictSigArity,
+        cutSigResult,
+        sigMayDiverge,
 
         seqDemand, seqDemandList, seqDmdType, seqStrictSig,
 
         evalDmd, cleanEvalDmd, cleanEvalProdDmd, isStrictDmd,
-        splitDmdTy, splitFVs,
+        splitDmdTy, splitFVs, splitProdCleanDmd,
         deferAfterIO,
         postProcessUnsat, postProcessDmdType,
 
-        splitProdDmd_maybe, peelCallDmd, mkCallDmd, mkWorkerDemand,
-        dmdTransformSig, dmdTransformDataConSig, dmdTransformDictSelSig,
+        splitProdDmd_maybe, peelCallDmd, mkCallDmd, mkCallDmdN, mkWorkerDemand,
+        dmdTransformSig, dmdTransformDictSelSig,
         argOneShots, argsOneShots, saturatedByOneShots,
         trimToType, TypeShape(..),
 
@@ -260,6 +265,10 @@
 mkSCall HyperStr = HyperStr
 mkSCall s        = SCall s
 
+mkSCallN :: Arity -> StrDmd -> StrDmd
+mkSCallN _ HyperStr = HyperStr
+mkSCallN n s        = nTimes n SCall s
+
 mkSProd :: [ArgStr] -> StrDmd
 mkSProd sx
   | any isHyperStr sx = HyperStr
@@ -339,9 +348,12 @@
 seqStrDmd (SCall s)    = seqStrDmd s
 seqStrDmd _            = ()
 
+seqListWith :: (a -> ()) -> [a] -> ()
+seqListWith _ [] = ()
+seqListWith s (x:xs) = s x `seq` seqListWith s xs
+
 seqStrDmdList :: [ArgStr] -> ()
-seqStrDmdList [] = ()
-seqStrDmdList (d:ds) = seqArgStr d `seq` seqStrDmdList ds
+seqStrDmdList = seqListWith seqArgStr
 
 seqArgStr :: ArgStr -> ()
 seqArgStr Lazy      = ()
@@ -440,7 +452,11 @@
 
 mkUCall :: Count -> UseDmd -> UseDmd
 --mkUCall c Used = Used c
-mkUCall c a  = UCall c a
+mkUCall c u  = UCall c u
+
+mkUCallN :: Arity -> Count -> UseDmd -> UseDmd
+--mkUCall c Used = Used c
+mkUCallN n c u  = nTimes n (UCall c) u
 
 mkUProd :: [ArgUse] -> UseDmd
 mkUProd ux
@@ -629,8 +645,7 @@
 seqUseDmd _            = ()
 
 seqArgUseList :: [ArgUse] -> ()
-seqArgUseList []     = ()
-seqArgUseList (d:ds) = seqArgUse d `seq` seqArgUseList ds
+seqArgUseList = seqListWith seqArgUse
 
 seqArgUse :: ArgUse -> ()
 seqArgUse (Use c u)  = c `seq` seqUseDmd u
@@ -661,7 +676,7 @@
 *                                                                      *
 ************************************************************************
 
-This domain differst from JointDemand in the sence that pure absence
+This domain differs from JointDemand in the sense that pure absence
 is taken away, i.e., we deal *only* with non-absent demands.
 
 Note [Strict demands]
@@ -705,9 +720,16 @@
 mkHeadStrict :: CleanDemand -> CleanDemand
 mkHeadStrict cd = cd { sd = HeadStr }
 
-mkOnceUsedDmd, mkManyUsedDmd :: CleanDemand -> Demand
+mkOnceUsedDmd, mkManyUsedDmd, mkNeverUsedDmd :: CleanDemand -> Demand
 mkOnceUsedDmd (JD {sd = s,ud = a}) = JD { sd = Str VanStr s, ud = Use One a }
 mkManyUsedDmd (JD {sd = s,ud = a}) = JD { sd = Str VanStr s, ud = Use Many a }
+mkNeverUsedDmd (JD {sd = s})       = JD { sd = Str VanStr s, ud = Abs }
+
+splitProdCleanDmd :: Arity -> CleanDemand -> Maybe [Demand]
+splitProdCleanDmd arity (JD {sd = s,ud = u}) = do
+  ss <- splitStrProdDmd arity s
+  us <- splitUseProdDmd arity u
+  return $ mkJointDmds ss us
 
 evalDmd :: Demand
 -- Evaluated strictly, and used arbitrarily deeply
@@ -728,6 +750,10 @@
   where go 0 = Used
         go n = mkUCall One $ go (n-1)
 
+mkCallDmdN :: Arity -> CleanDemand -> CleanDemand
+mkCallDmdN n (JD {sd = d, ud = u})
+  = JD { sd = mkSCallN n d, ud = mkUCallN n One u }
+
 cleanEvalDmd :: CleanDemand
 cleanEvalDmd = JD { sd = HeadStr, ud = Used }
 
@@ -787,6 +813,9 @@
 seqDmd :: Demand
 seqDmd = JD { sd = Str VanStr HeadStr, ud = Use One UHead }
 
+strictFieldDmd :: Demand
+strictFieldDmd = JD { sd = Str VanStr HeadStr, ud = Abs }
+
 oneifyDmd :: Demand -> Demand
 oneifyDmd (JD { sd = s, ud = Use _ a }) = JD { sd = s, ud = Use One a }
 oneifyDmd jd                            = jd
@@ -814,8 +843,7 @@
 seqDemand (JD {sd = s, ud = u}) = seqArgStr s `seq` seqArgUse u
 
 seqDemandList :: [Demand] -> ()
-seqDemandList [] = ()
-seqDemandList (d:ds) = seqDemand d `seq` seqDemandList ds
+seqDemandList = seqListWith seqDemand
 
 isStrictDmd :: Demand -> Bool
 -- See Note [Strict demands]
@@ -942,18 +970,20 @@
 
 
 DmdResult:     Dunno CPRResult
+               /         \
+           ThrowsExn      Converges CPRResult
                /
-           ThrowsExn
-             /
         Diverges
 
 
 CPRResult:         NoCPR
                    /    \
-            RetProd    RetSum ConTag
+  RetProd [DmdResult]    RetSum ConTag
+                  \     /
+                NeverReturns
 
 
-Product constructors return (Dunno (RetProd rs))
+Product constructors return (Converges (RetProd rs))
 In a fixpoint iteration, start from Diverges
 We have lubs, but not glbs; but that is ok.
 -}
@@ -965,82 +995,177 @@
 data Termination r
   = Diverges    -- Definitely diverges
   | ThrowsExn   -- Definitely throws an exception or diverges
+  | Converges r -- Definitely converges
   | Dunno r     -- Might diverge or converge
   deriving( Eq, Show )
 
 type DmdResult = Termination CPRResult
 
-data CPRResult = NoCPR          -- Top of the lattice
-               | RetProd        -- Returns a constructor from a product type
-               | RetSum ConTag  -- Returns a constructor from a data type
+data CPRResult = NoCPR               -- Top of the lattice
+               | RetProd [DmdResult] -- Returns a constructor from a product type
+               | RetSum ConTag       -- Returns a constructor from a data type
+               | NeverReturns        -- Never returns anything
                deriving( Eq, Show )
 
 lubCPR :: CPRResult -> CPRResult -> CPRResult
+lubCPR NeverReturns r              = r
+lubCPR r NeverReturns              = r
 lubCPR (RetSum t1) (RetSum t2)
   | t1 == t2                       = RetSum t1
-lubCPR RetProd     RetProd     = RetProd
-lubCPR _ _                     = NoCPR
+lubCPR (RetProd ds1) (RetProd ds2)
+  | ds1 `equalLength` ds2          = RetProd (zipWith lubDmdResult ds1 ds2)
+    -- I'm thinking the could be unequal if two branches of a GADT case
+    -- returned a product constructor from a different data type
+    -- Also we use [] to mean [top,...,top]
+lubCPR _ _                         = NoCPR
 
 lubDmdResult :: DmdResult -> DmdResult -> DmdResult
+lubDmdResult Diverges       (Converges c2) = Dunno c2
 lubDmdResult Diverges       r              = r
 lubDmdResult ThrowsExn      Diverges       = ThrowsExn
+lubDmdResult ThrowsExn      (Converges c2) = Dunno c2
 lubDmdResult ThrowsExn      r              = r
+lubDmdResult (Converges c1) Diverges       = Dunno c1
+lubDmdResult (Converges c1) ThrowsExn      = Dunno c1
+lubDmdResult (Converges c1) (Converges c2) = Converges (c1 `lubCPR` c2)
+lubDmdResult (Converges c1) (Dunno c2)     = Dunno (c1 `lubCPR` c2)
 lubDmdResult (Dunno c1)     Diverges       = Dunno c1
 lubDmdResult (Dunno c1)     ThrowsExn      = Dunno c1
+lubDmdResult (Dunno c1)     (Converges c2) = Dunno (c1 `lubCPR` c2)
 lubDmdResult (Dunno c1)     (Dunno c2)     = Dunno (c1 `lubCPR` c2)
 -- This needs to commute with defaultDmd, i.e.
 -- defaultDmd (r1 `lubDmdResult` r2) = defaultDmd r1 `lubDmd` defaultDmd r2
 -- (See Note [Default demand on free variables] for why)
 
 bothDmdResult :: DmdResult -> Termination () -> DmdResult
 -- See Note [Asymmetry of 'both' for DmdType and DmdResult]
 bothDmdResult _ Diverges   = Diverges
+bothDmdResult (Converges c1) (Dunno {}) = Dunno c1
 bothDmdResult r ThrowsExn  = case r of { Diverges -> r; _ -> ThrowsExn }
 bothDmdResult r (Dunno {}) = r
+bothDmdResult r (Converges {}) = r
 -- This needs to commute with defaultDmd, i.e.
 -- defaultDmd (r1 `bothDmdResult` r2) = defaultDmd r1 `bothDmd` defaultDmd r2
 -- (See Note [Default demand on free variables] for why)
 
 instance Outputable r => Outputable (Termination r) where
   ppr Diverges      = char 'b'
   ppr ThrowsExn     = char 'x'
+  ppr (Converges c) = char 't' <> ppr c
   ppr (Dunno c)     = ppr c
 
 instance Outputable CPRResult where
   ppr NoCPR        = empty
   ppr (RetSum n)   = char 'm' <> int n
-  ppr RetProd      = char 'm'
+  ppr (RetProd rs) = char 'm' <> parens (hcat (punctuate (char ',') (map ppr rs)))
+  ppr NeverReturns = text "m_"
 
 seqDmdResult :: DmdResult -> ()
 seqDmdResult Diverges  = ()
 seqDmdResult ThrowsExn = ()
+seqDmdResult (Converges c) = seqCPRResult c
 seqDmdResult (Dunno c) = seqCPRResult c
 
 seqCPRResult :: CPRResult -> ()
 seqCPRResult NoCPR        = ()
 seqCPRResult (RetSum n)   = n `seq` ()
-seqCPRResult RetProd      = ()
+seqCPRResult (RetProd rs) = seqListWith seqDmdResult rs
+seqCPRResult NeverReturns = ()
 
 
 ------------------------------------------------------------------------
 -- Combined demand result                                             --
 ------------------------------------------------------------------------
 
--- [cprRes] lets us switch off CPR analysis
--- by making sure that everything uses TopRes
-topRes, exnRes, botRes :: DmdResult
+topRes, convRes, exnRes, botRes :: DmdResult
 topRes = Dunno NoCPR
+convRes = Converges NoCPR
 exnRes = ThrowsExn
 botRes = Diverges
 
-cprSumRes :: ConTag -> DmdResult
-cprSumRes tag = Dunno $ RetSum tag
-
-cprProdRes :: [DmdType] -> DmdResult
-cprProdRes _arg_tys = Dunno $ RetProd
-
-vanillaCprProdRes :: Arity -> DmdResult
-vanillaCprProdRes _arity = Dunno $ RetProd
+cprSumRes :: Int -> ConTag -> DmdResult
+cprSumRes depth tag = cutDmdResult depth $ Converges $ RetSum tag
+
+cprProdRes :: Int -> [DmdResult] -> DmdResult
+cprProdRes depth arg_ress = cutDmdResult depth $ cprProdRes' arg_ress
+
+-- | cprProdRes with no depth limit.
+cprProdRes' :: [DmdResult] -> DmdResult
+cprProdRes' arg_ress = Converges $ RetProd arg_ress
+
+getDmdResult :: DmdType -> DmdResult
+getDmdResult (DmdType _ [] r) = r       -- Only for data-typed arguments!
+getDmdResult _                = topRes
+
+-- Forget that something might converge for sure
+divergeDmdResult :: DmdResult -> DmdResult
+divergeDmdResult r = r `lubDmdResult` botRes
+
+-- With nested CPR, DmdResult can be arbitrarily deep; consider
+-- data Rec1 = Foo Rec2 Rec2
+-- data Rec2 = Bar Rec1 Rec1
+--
+-- x = Foo y y
+-- y = Bar x x
+--
+-- So we need to forget information at a certain depth. We do that at all points
+-- where we are constructing new RetProd constructors.
+cutDmdResult :: Int -> DmdResult -> DmdResult
+cutDmdResult 0 _             = topRes
+cutDmdResult _ Diverges      = Diverges
+cutDmdResult _ ThrowsExn     = ThrowsExn
+cutDmdResult n (Converges c) = Converges (cutCPRResult n c)
+cutDmdResult n (Dunno c)     = Dunno     (cutCPRResult n c)
+
+cutCPRResult :: Int -> CPRResult -> CPRResult
+cutCPRResult 0 _               = NoCPR
+cutCPRResult _ NoCPR           = NoCPR
+cutCPRResult _ NeverReturns    = NeverReturns
+cutCPRResult _ (RetSum tag)    = RetSum tag
+cutCPRResult n (RetProd rs)    = RetProd (map (cutDmdResult (n-1)) rs)
+
+-- | Forget any CPR property for components that are lazy according to the
+-- first argument.
+forgetLazyCPR :: ArgStr -> DmdResult -> DmdResult
+forgetLazyCPR argStr res = case (argStr, res) of
+  (Lazy, _) -> topRes
+  (_, Dunno (RetProd rs)) -> Dunno $ deep rs
+  (_, Converges (RetProd rs)) -> Converges $ deep rs
+  _ -> res
+  where
+    deep rs = case splitArgStrProdDmd (length rs) argStr of
+      Nothing -> NoCPR
+      Just args -> RetProd $ zipWith forgetLazyCPR args rs
+
+-- Forget the CPR information, but remember if it converges or diverges
+-- Used for non-strict thunks and non-top-level things with sum type
+forgetCPR :: DmdResult -> DmdResult
+forgetCPR (Converges _) = Converges NoCPR
+forgetCPR (Dunno _) = Dunno NoCPR
+forgetCPR res = res
+
+forgetSumCPR :: DmdResult -> DmdResult
+forgetSumCPR (Converges r) = Converges (forgetSumCPR_help r)
+forgetSumCPR (Dunno r) = Dunno (forgetSumCPR_help r)
+forgetSumCPR res = res
+
+forgetSumCPR_help :: CPRResult -> CPRResult
+forgetSumCPR_help (RetProd ds) = RetProd (map forgetSumCPR ds)
+forgetSumCPR_help (RetSum _)   = NoCPR
+forgetSumCPR_help NeverReturns = NeverReturns
+forgetSumCPR_help NoCPR        = NoCPR
+
+splitNestedRes :: DmdResult -> [DmdResult]
+splitNestedRes Diverges      = repeat Diverges
+splitNestedRes ThrowsExn     = repeat ThrowsExn
+splitNestedRes (Dunno c)     = splitNestedCPR c
+splitNestedRes (Converges c) = splitNestedCPR c
+
+splitNestedCPR :: CPRResult -> [DmdResult]
+splitNestedCPR NoCPR        = repeat topRes
+splitNestedCPR (RetSum _)   = repeat topRes
+splitNestedCPR (RetProd cs) = cs
+splitNestedCPR NeverReturns = repeat $ Dunno NeverReturns
 
 isTopRes :: DmdResult -> Bool
 isTopRes (Dunno NoCPR) = True
@@ -1051,43 +1176,38 @@
 isBotRes Diverges   = True
 isBotRes ThrowsExn  = True
 isBotRes (Dunno {}) = False
-
-trimCPRInfo :: Bool -> Bool -> DmdResult -> DmdResult
-trimCPRInfo trim_all trim_sums res
-  = trimR res
-  where
-    trimR (Dunno c) = Dunno (trimC c)
-    trimR res       = res
-
-    trimC (RetSum n)   | trim_all || trim_sums = NoCPR
-                       | otherwise             = RetSum n
-    trimC RetProd      | trim_all  = NoCPR
-                       | otherwise = RetProd
-    trimC NoCPR = NoCPR
-
-returnsCPR_maybe :: DmdResult -> Maybe ConTag
-returnsCPR_maybe (Dunno c) = retCPR_maybe c
-returnsCPR_maybe _         = Nothing
-
-retCPR_maybe :: CPRResult -> Maybe ConTag
-retCPR_maybe (RetSum t)  = Just t
-retCPR_maybe RetProd     = Just fIRST_TAG
-retCPR_maybe NoCPR       = Nothing
+isBotRes (Converges {}) = False
+
+-- If the first argument is True, we only consider surely terminating DmdResults
+returnsCPR_maybe :: Bool -> DmdResult -> Maybe (ConTag, [DmdResult])
+returnsCPR_maybe _     (Converges c) = retCPR_maybe c
+returnsCPR_maybe False (Dunno c)     = retCPR_maybe c
+returnsCPR_maybe True  (Dunno _)     = Nothing
+returnsCPR_maybe _     Diverges      = Nothing
+returnsCPR_maybe _     ThrowsExn     = Nothing
+
+retCPR_maybe :: CPRResult -> Maybe (ConTag, [DmdResult])
+retCPR_maybe (RetSum t)   = Just (t, [])
+retCPR_maybe (RetProd rs) = Just (fIRST_TAG, rs)
+retCPR_maybe NoCPR        = Nothing
+retCPR_maybe NeverReturns = Nothing
 
 -- See Notes [Default demand on free variables]
 -- and [defaultDmd vs. resTypeArgDmd]
 defaultDmd :: Termination r -> Demand
-defaultDmd (Dunno {}) = absDmd
-defaultDmd _          = botDmd  -- Diverges or ThrowsExn
+defaultDmd (Dunno {})     = absDmd
+defaultDmd (Converges {}) = absDmd
+defaultDmd _              = botDmd  -- Diverges or ThrowsExn
 
 resTypeArgDmd :: Termination r -> Demand
 -- TopRes and BotRes are polymorphic, so that
 --      BotRes === (Bot -> BotRes) === ...
 --      TopRes === (Top -> TopRes) === ...
 -- This function makes that concrete
 -- Also see Note [defaultDmd vs. resTypeArgDmd]
-resTypeArgDmd (Dunno _) = topDmd
-resTypeArgDmd _         = botDmd   -- Diverges or ThrowsExn
+resTypeArgDmd (Dunno _)     = topDmd
+resTypeArgDmd (Converges _) = topDmd
+resTypeArgDmd _             = botDmd   -- Diverges or ThrowsExn
 
 {-
 Note [defaultDmd and resTypeArgDmd]
@@ -1260,6 +1380,10 @@
          -- Unique order, it is the same order for both
                               && ds1 == ds2 && res1 == res2
 
+lubDmdTypes :: [DmdType] -> DmdType
+lubDmdTypes [] = botDmdType
+lubDmdTypes tys = foldr1 lubDmdType tys
+
 lubDmdType :: DmdType -> DmdType -> DmdType
 lubDmdType d1 d2
   = DmdType lub_fv lub_ds lub_res
@@ -1290,9 +1414,10 @@
 toBothDmdArg :: DmdType -> BothDmdArg
 toBothDmdArg (DmdType fv _ r) = (fv, go r)
   where
-    go (Dunno {}) = Dunno ()
-    go ThrowsExn  = ThrowsExn
-    go Diverges   = Diverges
+    go (Dunno {})     = Dunno ()
+    go (Converges {}) = Converges ()
+    go ThrowsExn      = ThrowsExn
+    go Diverges       = Diverges
 
 bothDmdType :: DmdType -> BothDmdArg -> DmdType
 bothDmdType (DmdType fv1 ds1 r1) (fv2, t2)
@@ -1305,10 +1430,11 @@
 
 instance Outputable DmdType where
   ppr (DmdType fv ds res)
-    = hsep [hcat (map ppr ds) <> ppr res,
+    = hsep [hcat (map ppr ds) <> ppr_res,
             if null fv_elts then empty
             else braces (fsep (map pp_elt fv_elts))]
     where
+      ppr_res = if isTopRes res then empty else ppr res
       pp_elt (uniq, dmd) = ppr uniq <> text "->" <> ppr dmd
       fv_elts = nonDetUFMToList fv
         -- It's OK to use nonDetUFMToList here because we only do it for
@@ -1321,14 +1447,18 @@
 -- (lazy, absent, no CPR information, no termination information).
 -- Note that it is ''not'' the top of the lattice (which would be "may use everything"),
 -- so it is (no longer) called topDmd
-nopDmdType, botDmdType, exnDmdType :: DmdType
+nopDmdType, botDmdType, exnDmdType, litDmdType :: DmdType
 nopDmdType = DmdType emptyDmdEnv [] topRes
 botDmdType = DmdType emptyDmdEnv [] botRes
 exnDmdType = DmdType emptyDmdEnv [] exnRes
+litDmdType = DmdType emptyDmdEnv [] convRes
 
-cprProdDmdType :: Arity -> DmdType
-cprProdDmdType arity
-  = DmdType emptyDmdEnv [] (vanillaCprProdRes arity)
+cprProdDmdType :: Int -> [DmdResult] -> DmdType
+cprProdDmdType depth arg_ress
+  = DmdType emptyDmdEnv [] $ cprProdRes depth arg_ress
+
+cprSumDmdType :: Int -> ConTag -> DmdType
+cprSumDmdType depth tag = DmdType emptyDmdEnv [] $ cprSumRes depth tag
 
 isTopDmdType :: DmdType -> Bool
 isTopDmdType (DmdType env [] res)
@@ -1380,16 +1510,17 @@
 -- exit?
 -- * We have to kill all strictness demands (i.e. lub with a lazy demand)
 -- * We can keep usage information (i.e. lub with an absent demand)
--- * We have to kill definite divergence
+-- * We have to kill definite divergence and definite convergence
 -- * We can keep CPR information.
 -- See Note [IO hack in the demand analyser] in DmdAnal
 deferAfterIO :: DmdType -> DmdType
 deferAfterIO d@(DmdType _ _ res) =
     case d `lubDmdType` nopDmdType of
         DmdType fv ds _ -> DmdType fv ds (defer_res res)
   where
-  defer_res r@(Dunno {}) = r
-  defer_res _            = topRes  -- Diverges and ThrowsExn
+  defer_res (Converges r) = Dunno r
+  defer_res r@(Dunno {})  = r
+  defer_res _             = Dunno NeverReturns  -- Diverges and ThrowsExn
 
 strictenDmd :: Demand -> CleanDemand
 strictenDmd (JD { sd = s, ud = u})
@@ -1435,12 +1566,15 @@
     = (postProcessDmdEnv du fv, term_info)
     where
        term_info = case postProcessDmdResult ss res_ty of
-                     Dunno _   -> Dunno ()
-                     ThrowsExn -> ThrowsExn
-                     Diverges  -> Diverges
+                     Dunno _     -> Dunno ()
+                     Converges _ -> Converges ()
+                     ThrowsExn   -> ThrowsExn
+                     Diverges    -> Diverges
 
 postProcessDmdResult :: Str () -> DmdResult -> DmdResult
-postProcessDmdResult Lazy           _         = topRes
+    -- if we use it lazily, there cannot be divergence worrying us
+    -- See Note [Termination information and arguments]
+postProcessDmdResult Lazy           _         = convRes
 postProcessDmdResult (Str ExnStr _) ThrowsExn = topRes  -- Key point!
 -- Note that only ThrowsExn results can be caught, not Diverges
 postProcessDmdResult _              res       = res
@@ -1546,8 +1680,8 @@
    - And finally termination information: If r says that f diverges for sure,
      then this holds when the demand guarantees that two arguments are going to
      be passed. If the demand is lower, we may just as well converge.
-     If we were tracking definite convegence, than that would still hold under
-     a weaker demand than expected by the demand transformer.
+     Definite convegence still holds under a weaker demand than expected by the
+     demand transformer.
  * Not enough demand from the usage side: The missing usage can be expanded
    using UCall Many, therefore this is subsumed by the third case:
  * At least one of the uses has a cardinality of Many.
@@ -1713,6 +1847,34 @@
 
 If this same function is applied to one arg, all we can say is that it
 uses x with <L,U>, and its arg with demand <L,U>.
+
+
+Note [Termination information and arguments]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+A strictness signature of <L>t indicates:
+    If you apply me to one argument, I will surely terminate (even if this
+    argument may diverge).
+Therefore, in postProcessDmdResult, we replace the termination info of a lazy
+argument by Converges.
+
+For strict arguments, we do not do that. But usually, <S>t is not possible anyways:
+Assume such a function is applied to undefined. This diverges, because it is strict,
+and it converges, because of the terminating flag.
+
+One exception to this rule are unlifted arguments. These cannot be undefined, so the
+function is (vacuously) strict in them. But moreover, it is important that we treat
+them as strict! Consider I# (or any function with an unlifted argument type). We
+clearly want "I# 1#" to be terminating, and also "I# x" and "I# (x +# 2#)".
+But not "I# (x `quotInt#` 0#)"! Therefore, we need to analyze the argument with a strict
+demand, so that postProcessDmdResult will not hide the termination result of the argument,
+and bothDmdType takes case of erasing the Converges coming from I#.
+
+This is a property not just of primitive operations. Consider
+  f :: Bool -> (Int# -> b) -> b
+  f b g = g (if b then 1# else 0#)
+Is this strict in `b`? Yes, it is! So we want to consider any function with an
+unlifted argument type as strict. Hence we do that conveniently in dmdTransformThunkDmd.
+And therefore we do not have to worry about the strictness on arguments in primops.txt.pp
 -}
 
 newtype StrictSig = StrictSig DmdType
@@ -1740,6 +1902,10 @@
 increaseStrictSigArity arity_increase (StrictSig (DmdType env dmds res))
   = StrictSig (DmdType env (replicate arity_increase topDmd ++ dmds) res)
 
+cutSigResult :: Int -> StrictSig -> StrictSig
+cutSigResult depth (StrictSig (DmdType env dmds res))
+  = StrictSig $ DmdType env dmds $ cutDmdResult depth res
+
 isTopSig :: StrictSig -> Bool
 isTopSig (StrictSig ty) = isTopDmdType ty
 
@@ -1758,44 +1924,32 @@
 botSig = StrictSig botDmdType
 exnSig = StrictSig exnDmdType
 
-cprProdSig :: Arity -> StrictSig
-cprProdSig arity = StrictSig (cprProdDmdType arity)
+cprProdSig :: Int -> [DmdResult] -> StrictSig
+cprProdSig depth arg_ress = StrictSig (cprProdDmdType depth arg_ress)
 
 seqStrictSig :: StrictSig -> ()
 seqStrictSig (StrictSig ty) = seqDmdType ty
 
+sigMayDiverge :: StrictSig -> StrictSig
+sigMayDiverge (StrictSig (DmdType env ds res)) = (StrictSig (DmdType env ds (divergeDmdResult res)))
+
+convergeSig :: StrictSig -> StrictSig
+convergeSig (StrictSig (DmdType fv args r)) = StrictSig (DmdType fv args (convergeResult r))
+
+convergeResult :: DmdResult -> DmdResult
+convergeResult Diverges      = Converges NoCPR
+convergeResult ThrowsExn     = Converges NoCPR
+convergeResult (Dunno c)     = Converges c
+convergeResult (Converges c) = Converges c
+
 dmdTransformSig :: StrictSig -> CleanDemand -> DmdType
 -- (dmdTransformSig fun_sig dmd) considers a call to a function whose
 -- signature is fun_sig, with demand dmd.  We return the demand
 -- that the function places on its context (eg its args)
 dmdTransformSig (StrictSig dmd_ty@(DmdType _ arg_ds _)) cd
   = postProcessUnsat (peelManyCalls (length arg_ds) cd) dmd_ty
     -- see Note [Demands from unsaturated function calls]
 
-dmdTransformDataConSig :: Arity -> StrictSig -> CleanDemand -> DmdType
--- Same as dmdTransformSig but for a data constructor (worker),
--- which has a special kind of demand transformer.
--- If the constructor is saturated, we feed the demand on
--- the result into the constructor arguments.
-dmdTransformDataConSig arity (StrictSig (DmdType _ _ con_res))
-                             (JD { sd = str, ud = abs })
-  | Just str_dmds <- go_str arity str
-  , Just abs_dmds <- go_abs arity abs
-  = DmdType emptyDmdEnv (mkJointDmds str_dmds abs_dmds) con_res
-                -- Must remember whether it's a product, hence con_res, not TopRes
-
-  | otherwise   -- Not saturated
-  = nopDmdType
-  where
-    go_str 0 dmd        = splitStrProdDmd arity dmd
-    go_str n (SCall s') = go_str (n-1) s'
-    go_str n HyperStr   = go_str (n-1) HyperStr
-    go_str _ _          = Nothing
-
-    go_abs 0 dmd            = splitUseProdDmd arity dmd
-    go_abs n (UCall One u') = go_abs (n-1) u'
-    go_abs _ _              = Nothing
-
 dmdTransformDictSelSig :: StrictSig -> CleanDemand -> DmdType
 -- Like dmdTransformDataConSig, we have a special demand transformer
 -- for dictionary selectors.  If the selector is saturated (ie has one
@@ -2159,21 +2313,25 @@
   put_ bh (Dunno c)     = do { putByte bh 0; put_ bh c }
   put_ bh ThrowsExn     = putByte bh 1
   put_ bh Diverges      = putByte bh 2
+  put_ bh (Converges c) = do { putByte bh 3; put_ bh c }
 
   get bh = do { h <- getByte bh
               ; case h of
                   0 -> do { c <- get bh; return (Dunno c) }
                   1 -> return ThrowsExn
+                  3 -> do { c <- get bh; return (Converges c) }
                   _ -> return Diverges }
 
 instance Binary CPRResult where
     put_ bh (RetSum n)   = do { putByte bh 0; put_ bh n }
-    put_ bh RetProd      = putByte bh 1
+    put_ bh (RetProd rs) = do { putByte bh 1; put_ bh rs }
     put_ bh NoCPR        = putByte bh 2
+    put_ bh NeverReturns = putByte bh 3
 
     get  bh = do
             h <- getByte bh
             case h of
-              0 -> do { n <- get bh; return (RetSum n) }
-              1 -> return RetProd
-              _ -> return NoCPR
+              0 -> do { n  <- get bh; return (RetSum n) }
+              1 -> do { rs <- get bh; return (RetProd rs) }
+              2 -> return NoCPR
+              _ -> return NeverReturns
diff --git a/compiler/basicTypes/MkId.hs b/compiler/basicTypes/MkId.hs
--- a/compiler/basicTypes/MkId.hs
+++ b/compiler/basicTypes/MkId.hs
@@ -383,14 +383,12 @@
     wkr_arity = dataConRepArity data_con
     wkr_info  = noCafIdInfo
                 `setArityInfo`          wkr_arity
-                `setStrictnessInfo`     wkr_sig
                 `setUnfoldingInfo`      evaldUnfolding  -- Record that it's evaluated,
                                                         -- even if arity = 0
                 `setLevityInfoWithType` alg_wkr_ty
                   -- NB: unboxed tuples have workers, so we can't use
                   -- setNeverLevPoly
 
-    wkr_sig = mkClosedStrictSig (replicate wkr_arity topDmd) (dataConCPR data_con)
         --      Note [Data-con worker strictness]
         -- Notice that we do *not* say the worker Id is strict
         -- even if the data constructor is declared strict
@@ -427,33 +425,6 @@
                    mkLams nt_tvs $ Lam id_arg1 $
                    wrapNewTypeBody tycon res_ty_args (Var id_arg1)
 
-dataConCPR :: DataCon -> DmdResult
-dataConCPR con
-  | isDataTyCon tycon     -- Real data types only; that is,
-                          -- not unboxed tuples or newtypes
-  , null (dataConExTyVars con)  -- No existentials
-  , wkr_arity > 0
-  , wkr_arity <= mAX_CPR_SIZE
-  = if is_prod then vanillaCprProdRes (dataConRepArity con)
-               else cprSumRes (dataConTag con)
-  | otherwise
-  = topRes
-  where
-    is_prod   = isProductTyCon tycon
-    tycon     = dataConTyCon con
-    wkr_arity = dataConRepArity con
-
-    mAX_CPR_SIZE :: Arity
-    mAX_CPR_SIZE = 10
-    -- We do not treat very big tuples as CPR-ish:
-    --      a) for a start we get into trouble because there aren't
-    --         "enough" unboxed tuple types (a tiresome restriction,
-    --         but hard to fix),
-    --      b) more importantly, big unboxed tuples get returned mainly
-    --         on the stack, and are often then allocated in the heap
-    --         by the caller.  So doing CPR for them may in fact make
-    --         things worse.
-
 {-
 -------------------------------------------------
 --         Data constructor representation
@@ -475,32 +446,6 @@
                        -- Bind these src-level vars, returning the
                        -- rep-level vars to bind in the pattern
 
-{-
-Note [Inline partially-applied constructor wrappers]
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-We allow the wrapper to inline when partially applied to avoid
-boxing values unnecessarily. For example, consider
-
-   data Foo a = Foo !Int a
-
-   instance Traversable Foo where
-     traverse f (Foo i a) = Foo i <$> f a
-
-This desugars to
-
-   traverse f foo = case foo of
-        Foo i# a -> let i = I# i#
-                    in map ($WFoo i) (f a)
-
-If the wrapper `$WFoo` is not inlined, we get a fruitless reboxing of `i`.
-But if we inline the wrapper, we get
-
-   map (\a. case i of I# i# a -> Foo i# a) (f a)
-
-and now case-of-known-constructor eliminates the redundant allocation.
--}
-
 mkDataConRep :: DynFlags
              -> FamInstEnvs
              -> Name
@@ -530,29 +475,21 @@
                              -- so it not make sure that the CAF info is sane
                          `setNeverLevPoly`      wrap_ty
 
-             wrap_sig = mkClosedStrictSig wrap_arg_dmds (dataConCPR data_con)
+             wrap_sig = mkClosedStrictSig wrap_arg_dmds topRes
 
              wrap_arg_dmds =
                replicate (length theta) topDmd ++ map mk_dmd arg_ibangs
                -- Don't forget the dictionary arguments when building
                -- the strictness signature (#14290).
 
              mk_dmd str | isBanged str = evalDmd
-                        | otherwise           = topDmd
+                        | otherwise    = topDmd
 
              wrap_prag = alwaysInlinePragma `setInlinePragmaActivation`
                          ActiveAfter NoSourceText 2
                          -- See Note [Activation for data constructor wrappers]
 
-             -- The wrapper will usually be inlined (see wrap_unf), so its
-             -- strictness and CPR info is usually irrelevant. But this is
-             -- not always the case; GHC may choose not to inline it. In
-             -- particular, the wrapper constructor is not inlined inside
-             -- an INLINE rhs or when it is not applied to any arguments.
-             -- See Note [Inline partially-applied constructor wrappers]
-             -- Passing Nothing here allows the wrapper to inline when
-             -- unsaturated.
-             wrap_unf = mkInlineUnfolding wrap_rhs
+             wrap_unf = mkDataConWrapUnfolding wrap_arity wrap_rhs
              wrap_rhs = mkLams wrap_tvs $
                         mkLams wrap_args $
                         wrapFamInstBody tycon res_ty_args $
diff --git a/compiler/coreSyn/CoreUnfold.hs b/compiler/coreSyn/CoreUnfold.hs
--- a/compiler/coreSyn/CoreUnfold.hs
+++ b/compiler/coreSyn/CoreUnfold.hs
@@ -25,6 +25,7 @@
         mkTopUnfolding, mkSimpleUnfolding, mkWorkerUnfolding,
         mkInlineUnfolding, mkInlineUnfoldingWithArity,
         mkInlinableUnfolding, mkWwInlineRule,
+        mkDataConWrapUnfolding,
         mkCompulsoryUnfolding, mkDFunUnfolding,
         specUnfolding,
 
@@ -159,6 +160,20 @@
                     , ug_boring_ok = boring_ok }
     boring_ok = inlineBoringOk expr'
 
+mkDataConWrapUnfolding :: Arity -> CoreExpr -> Unfolding
+mkDataConWrapUnfolding arity expr
+  = mkCoreUnfolding InlineStable
+                    True
+                    expr'
+                    UnfWhen { ug_arity = arity
+                            , ug_unsat_ok = unSaturatedOk
+                            , ug_boring_ok = boringCxtOk
+                            }
+                    -- See Note [Inline data constructor wrappers aggresively]
+                    -- and Note [Inline partially-applied constructor wrappers].
+  where
+    expr' = simpleOptExpr expr
+
 mkInlinableUnfolding :: DynFlags -> CoreExpr -> Unfolding
 mkInlinableUnfolding dflags expr
   = mkUnfolding dflags InlineStable False False expr'
@@ -315,6 +330,49 @@
 it gets fixed up next round.  And it should be rare, because large
 let-bound things that are dead are usually caught by preInlineUnconditionally
 
+Note [Inline data constructor wrappers aggresively]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The wrappers for strict data type constructors are to be inlined even in
+a boring context. This increases the chance that the demand analyzer will
+see the real constructor and return a nested CPR property.
+
+For example:
+    data P a = P !a !b
+    f :: Int -> P Int Int
+    f x = P x x
+previously, the demand analyzer would only see
+    f x = $WP x x
+and infer a strictness signature of "<S,U>m(,)", i.e. a non-nested CPR property.
+
+But if we inline $WP, we get
+    f x = case x of _ -> P x x
+and we would get "<S,U>,m(t(),t())", i.e. a nested CPR property.
+
+A real world example of this issue is the function mean in [ticket:2289#comment:1].
+
+Note [Inline partially-applied constructor wrappers]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+We allow the wrapper to inline when partially applied to avoid
+boxing values unnecessarily. For example, consider
+
+   data Foo a = Foo !Int a
+
+   instance Traversable Foo where
+     traverse f (Foo i a) = Foo i <$> f a
+
+This desugars to
+
+   traverse f foo = case foo of
+        Foo i# a -> let i = I# i#
+                    in map ($WFoo i) (f a)
+
+If the wrapper `$WFoo` is not inlined, we get a fruitless reboxing of `i`.
+But if we inline the wrapper, we get
+
+   map (\a. case i of I# i# a -> Foo i# a) (f a)
+
+and now case-of-known-constructor eliminates the redundant allocation.
 
 ************************************************************************
 *                                                                      *
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -908,6 +908,8 @@
 
   maxWorkerArgs         :: Int,
 
+  maxCprDepth           :: Int,
+
   ghciHistSize          :: Int,
 
   -- | MsgDoc output action: use "ErrUtils" instead of this if you can
@@ -1721,6 +1723,8 @@
 
         maxWorkerArgs = 10,
 
+        maxCprDepth = 4,
+
         ghciHistSize = 50, -- keep a log of length 50 by default
 
         -- Logging
@@ -3271,6 +3275,8 @@
       (floatSuffix (\n d -> d {ufKeenessFactor = n}))
   , make_ord_flag defFlag "fmax-worker-args"
       (intSuffix (\n d -> d {maxWorkerArgs = n}))
+  , make_ord_flag defFlag "fcpr-depth"
+      (intSuffix (\n d -> d {maxCprDepth = n}))
   , make_ord_flag defGhciFlag "fghci-hist-size"
       (intSuffix (\n d -> d {ghciHistSize = n}))
   , make_ord_flag defGhcFlag "fmax-inline-alloc-size"
diff --git a/compiler/prelude/PrimOp.hs b/compiler/prelude/PrimOp.hs
--- a/compiler/prelude/PrimOp.hs
+++ b/compiler/prelude/PrimOp.hs
@@ -563,8 +563,10 @@
 
 primOpSig :: PrimOp -> ([TyVar], [Type], Type, Arity, StrictSig)
 primOpSig op
-  = (tyvars, arg_tys, res_ty, arity, primOpStrictness op arity)
+  = (tyvars, arg_tys, res_ty, arity, strict_sig)
   where
+    strict_sig | primOpOkForSpeculation op = convergeSig $ primOpStrictness op arity
+               | otherwise                 =               primOpStrictness op arity
     arity = length arg_tys
     (tyvars, arg_tys, res_ty)
       = case (primOpInfo op) of
diff --git a/compiler/prelude/primops.txt.pp b/compiler/prelude/primops.txt.pp
--- a/compiler/prelude/primops.txt.pp
+++ b/compiler/prelude/primops.txt.pp
@@ -69,6 +69,8 @@
    can_fail         = False   -- See Note Note [PrimOp can_fail and has_side_effects] in PrimOp
    commutable       = False
    code_size        = { primOpCodeSizeDefault }
+   -- Strictness is turned to terminating in PrimOp.primOpSig, if allowed
+   -- Also see [Termination information and arguments]
    strictness       = { \ arity -> mkClosedStrictSig (replicate arity topDmd) topRes }
    fixity           = Nothing
    llvm_only        = False
diff --git a/compiler/stranal/DmdAnal.hs b/compiler/stranal/DmdAnal.hs
--- a/compiler/stranal/DmdAnal.hs
+++ b/compiler/stranal/DmdAnal.hs
@@ -32,7 +32,7 @@
 import Coercion         ( Coercion, coVarsOfCo )
 import FamInstEnv
 import Util
-import Maybes           ( isJust )
+import Maybes
 import TysWiredIn
 import TysPrim          ( realWorldStatePrimTy )
 import ErrUtils         ( dumpIfSet_dyn )
@@ -140,11 +140,15 @@
 -- See â†¦* relation in the Cardinality Analysis paper
 dmdAnalStar :: AnalEnv
             -> Demand   -- This one takes a *Demand*
-            -> CoreExpr -> (BothDmdArg, CoreExpr)
+            -> CoreExpr
+            -> (BothDmdArg, DmdResult, CoreExpr)
 dmdAnalStar env dmd e
-  | (defer_and_use, cd) <- toCleanDmd dmd (exprType e)
+  | (shell, cd)         <- toCleanDmd dmd (exprType e)
   , (dmd_ty, e')        <- dmdAnal env cd e
-  = (postProcessDmdType defer_and_use dmd_ty, e')
+  = let dmd_ty' = postProcessDmdType shell dmd_ty
+    in -- pprTrace "dmdAnalStar" (vcat [ppr e, ppr dmd, ppr defer_and_use, ppr dmd_ty, ppr dmd_ty'])
+        -- We also return the unmodified DmdResult, to store it in nested CPR information
+       (dmd_ty', getDmdResult dmd_ty,  e')
 
 -- Main Demand Analsysis machinery
 dmdAnal, dmdAnal' :: AnalEnv
@@ -157,13 +161,13 @@
 dmdAnal env d e = -- pprTrace "dmdAnal" (ppr d <+> ppr e) $
                   dmdAnal' env d e
 
-dmdAnal' _ _ (Lit lit)     = (nopDmdType, Lit lit)
+dmdAnal' _ _ (Lit lit)     = (litDmdType, Lit lit)
 dmdAnal' _ _ (Type ty)     = (nopDmdType, Type ty)      -- Doesn't happen, in fact
 dmdAnal' _ _ (Coercion co)
   = (unitDmdType (coercionDmdEnv co), Coercion co)
 
-dmdAnal' env dmd (Var var)
-  = (dmdTransform env var dmd, Var var)
+dmdAnal' env dmd (Var var)     = dmdAnalVarApp env dmd var []
+dmdAnal' env dmd (App fun arg) = dmdAnalApp    env dmd fun [arg]
 
 dmdAnal' env dmd (Cast e co)
   = (dmd_ty `bothDmdType` mkBothDmdArg (coercionDmdEnv co), Cast e' co)
@@ -188,33 +192,6 @@
   where
     (dmd_ty, e') = dmdAnal env dmd e
 
-dmdAnal' env dmd (App fun (Type ty))
-  = (fun_ty, App fun' (Type ty))
-  where
-    (fun_ty, fun') = dmdAnal env dmd fun
-
--- Lots of the other code is there to make this
--- beautiful, compositional, application rule :-)
-dmdAnal' env dmd (App fun arg)
-  = -- This case handles value arguments (type args handled above)
-    -- Crucially, coercions /are/ handled here, because they are
-    -- value arguments (Trac #10288)
-    let
-        call_dmd          = mkCallDmd dmd
-        (fun_ty, fun')    = dmdAnal env call_dmd fun
-        (arg_dmd, res_ty) = splitDmdTy fun_ty
-        (arg_ty, arg')    = dmdAnalStar env (dmdTransformThunkDmd arg arg_dmd) arg
-    in
---    pprTrace "dmdAnal:app" (vcat
---         [ text "dmd =" <+> ppr dmd
---         , text "expr =" <+> ppr (App fun arg)
---         , text "fun dmd_ty =" <+> ppr fun_ty
---         , text "arg dmd =" <+> ppr arg_dmd
---         , text "arg dmd_ty =" <+> ppr arg_ty
---         , text "res dmd_ty =" <+> ppr res_ty
---         , text "overall res dmd_ty =" <+> ppr (res_ty `bothDmdType` arg_ty) ])
-    (res_ty `bothDmdType` arg_ty, App fun' arg')
-
 -- this is an anonymous lambda, since @dmdAnalRhsLetDown@ uses @collectBinders@
 dmdAnal' env dmd (Lam var body)
   | isTyVar var
@@ -230,8 +207,54 @@
         env'             = extendSigsWithLam env var
         (body_ty, body') = dmdAnal env' body_dmd body
         (lam_ty, var')   = annotateLamIdBndr env notArgOfDfun body_ty var
+        lam_ty'          = postProcessUnsat defer_and_use lam_ty
+    in
+    -- pprTrace "dmdAnal:Lam" (vcat [ text "dmd" <+> ppr dmd
+    --                              , text "body_ty" <+> ppr body_ty
+    --                              , text "lam_ty" <+> ppr lam_ty
+    --                              , text "lam_ty'" <+> ppr lam_ty'
+    --                              ]) $
+    (lam_ty', Lam var' body')
+
+dmdAnal' env dmd (Case scrut case_bndr ty [alt@(DataAlt dc, bndrs, _)])
+  -- Only one alternative with a product constructor, and a complex scrutinee
+  | let tycon = dataConTyCon dc
+  , isProductTyCon tycon
+  -- If the scrutinee is not trivial, we are not going to get much from
+  -- passing the body demand to it. OTOH, we might be getting some nested CPR
+  -- information from the scrutinee that we can feed into the bound variables.
+  , not (exprIsTrivial scrut)
+  , Just rec_tc' <- checkRecTc (ae_rec_tc env) tycon
+  = let
+        scrut_dmd = mkProdDmd (replicate (dataConRepArity dc) topDmd)
+        (scrut_ty, scrut') = dmdAnal env scrut_dmd scrut
+
+        scrut_ret  = getDmdResult scrut_ty
+        comp_rets  = take (dataConRepArity dc) $ splitNestedRes scrut_ret -- infinite list!
+
+        -- Build a surely converging, CPR carrying signature for the builder,
+        -- and for the components use what we get from the scrunitee
+        case_bndr_sig = cprProdSig (maxCprDepth (ae_dflags env)) comp_rets
+
+        env_w_tc              = env { ae_rec_tc = rec_tc' }
+        env_alt               = extendAnalEnvs1 NotTopLevel env_w_tc $
+            (case_bndr, case_bndr_sig) :
+            zipWithEqual "dmdAnal:CaseComplex"
+               (\b ty -> (b, mkClosedStrictSig [] ty)) bndrs  comp_rets
+
+        (alt_ty, alt')        = dmdAnalAlt env_alt dmd case_bndr alt
+        (alt_ty1, case_bndr') = annotateBndr env alt_ty case_bndr
+        alt_ty2 | io_hack_reqd scrut dc bndrs = deferAfterIO alt_ty1
+                | otherwise                   = alt_ty1
+        res_ty                = alt_ty2 `bothDmdType` toBothDmdArg scrut_ty
     in
-    (postProcessUnsat defer_and_use lam_ty, Lam var' body')
+    -- pprTrace "dmdAnal:CaseComplex" (vcat [ text "scrut" <+> ppr scrut
+    --                                , text "dmd" <+> ppr dmd
+    --                                , text "scrut_dmd" <+> ppr scrut_dmd
+    --                                , text "scrut_ty" <+> ppr scrut_ty
+    --                                , text "alt_ty" <+> ppr alt_ty1
+    --                                , text "res_ty" <+> ppr res_ty ]) $
+    (res_ty, Case scrut' case_bndr' ty [alt'])
 
 dmdAnal' env dmd (Case scrut case_bndr ty [(DataAlt dc, bndrs, rhs)])
   -- Only one alternative with a product constructor
@@ -250,7 +273,7 @@
 
         -- Compute demand on the scrutinee
         -- See Note [Demand on scrutinee of a product case]
-        scrut_dmd          = mkProdDmd (addDataConStrictness dc id_dmds)
+        scrut_dmd          = mkProdDmd id_dmds
         (scrut_ty, scrut') = dmdAnal env scrut_dmd scrut
         res_ty             = alt_ty3 `bothDmdType` toBothDmdArg scrut_ty
         case_bndr'         = setIdDemandInfo case_bndr case_bndr_dmd
@@ -267,12 +290,11 @@
 
 dmdAnal' env dmd (Case scrut case_bndr ty alts)
   = let      -- Case expression with multiple alternatives
-        (alt_tys, alts')     = mapAndUnzip (dmdAnalAlt env dmd case_bndr) alts
+        case_bndr_sig        = convergeSig nopSig
+        env_alt              = extendAnalEnv NotTopLevel env case_bndr case_bndr_sig
+        (alt_tys, alts')     = mapAndUnzip (dmdAnalAlt env_alt dmd case_bndr) alts
         (scrut_ty, scrut')   = dmdAnal env cleanEvalDmd scrut
-        (alt_ty, case_bndr') = annotateBndr env (foldr lubDmdType botDmdType alt_tys) case_bndr
-                               -- NB: Base case is botDmdType, for empty case alternatives
-                               --     This is a unit for lubDmdType, and the right result
-                               --     when there really are no alternatives
+        (alt_ty, case_bndr') = annotateBndr env (lubDmdTypes alt_tys) case_bndr
         res_ty               = alt_ty `bothDmdType` toBothDmdArg scrut_ty
     in
 --    pprTrace "dmdAnal:Case2" (vcat [ text "scrut" <+> ppr scrut
@@ -304,7 +326,7 @@
     (body_ty', id_dmd) = findBndrDmd env notArgOfDfun body_ty id
     id'                = setIdDemandInfo id id_dmd
 
-    (rhs_ty, rhs')     = dmdAnalStar env (dmdTransformThunkDmd rhs id_dmd) rhs
+    (rhs_ty, _, rhs')  = dmdAnalStar env (dmdTransformThunkDmd rhs id_dmd) rhs
     final_ty           = body_ty' `bothDmdType` rhs_ty
 
 dmdAnal' env dmd (Let (NonRec id rhs) body)
@@ -336,6 +358,9 @@
         body_ty1                = deleteFVs body_ty (map fst pairs)
         body_ty2                = addLazyFVs body_ty1 lazy_fv -- see Note [Lazy and unleashable free variables]
     in
+    -- pprTrace "dmdAnal:LetRec" (vcat [ text "body_ty" <+> ppr body_ty
+    --                                 , text "body_ty1" <+> ppr body_ty1
+    --                                 , text "body_ty2" <+> ppr body_ty2]) $
     body_ty2 `seq`
     (body_ty2,  Let (Rec pairs') body')
 
@@ -363,7 +388,11 @@
   , (alt_ty, dmds) <- findBndrsDmds env rhs_ty bndrs
   , let case_bndr_dmd = findIdDemand alt_ty case_bndr
         id_dmds       = addCaseBndrDmd case_bndr_dmd dmds
-  = (alt_ty, (con, setBndrsDemandInfo bndrs id_dmds, rhs'))
+  =
+    -- pprTrace "dmdAnalAlt" (vcat [ text "rhs_ty" <+> ppr rhs_ty
+    --                             , text "alt_ty" <+> ppr alt_ty
+    --                             ]) $
+    (alt_ty, (con, setBndrsDemandInfo bndrs id_dmds, rhs'))
 
 
 {- Note [IO hack in the demand analyser]
@@ -478,9 +507,6 @@
         -- this function plus demand on its free variables
 
 dmdTransform env var dmd
-  | isDataConWorkId var                          -- Data constructor
-  = dmdTransformDataConSig (idArity var) (idStrictness var) dmd
-
   | gopt Opt_DmdTxDictSel (ae_dflags env),
     Just _ <- isClassOpId_maybe var -- Dictionary component selector
   = dmdTransformDictSelSig (idStrictness var) dmd
@@ -491,14 +517,106 @@
     res
 
   | Just (sig, top_lvl) <- lookupSigEnv env var  -- Local letrec bound thing
-  , let fn_ty = dmdTransformSig sig dmd
+  , let fn_ty = dmdTransformSig (cutSigResult (maxCprDepth (ae_dflags env)) sig) dmd
   = -- pprTrace "dmdTransform" (vcat [ppr var, ppr sig, ppr dmd, ppr fn_ty]) $
     if isTopLevel top_lvl
     then fn_ty   -- Don't record top level things
-    else addVarDmd fn_ty var (mkOnceUsedDmd dmd)
+    else addVarDmd fn_ty var (mkOnceUsedDmd' env (idType var) dmd)
 
   | otherwise                                    -- Local non-letrec-bound thing
-  = unitDmdType (unitVarEnv var (mkOnceUsedDmd dmd))
+  = DmdType (unitVarEnv var (mkOnceUsedDmd' env (idType var) dmd)) [] $
+      if isUnliftedType (idType var) then convRes else topRes
+
+----------------
+
+-- | Make a use-once demand, possibly with deep strictness demand in case of a
+-- product type with strictness annotations.
+mkOnceUsedDmd' :: AnalEnv -> Type -> CleanDemand -> Demand
+mkOnceUsedDmd' env ty0 dmd = mkOnceUsedDmd dmd `bothDmd` additionalDmd ty0
+  where
+    additionalDmd ty
+      | Just (_, _, arg_tys, _)
+        <- deepSplitProductType_maybe (ae_fam_envs env) ty
+      = mkNeverUsedDmd $ mkProdDmd $ map fieldDmd arg_tys
+      | otherwise = strictFieldDmd
+
+    fieldDmd (ty, MarkedStrict) = additionalDmd ty
+    fieldDmd (_, NotMarkedStrict) = absDmd
+
+----------------
+dmdAnalApp :: AnalEnv -> CleanDemand -> CoreExpr
+           -> [CoreExpr] -> (DmdType, CoreExpr)
+dmdAnalApp env dmd (App fun arg) args = dmdAnalApp env dmd fun (arg:args)
+dmdAnalApp env dmd (Var fun)     args = dmdAnalVarApp env dmd fun args
+dmdAnalApp env dmd other_fun     args = dmdAnalOtherApp env dmd other_fun args
+
+----------------
+dmdAnalOtherApp :: AnalEnv -> CleanDemand -> CoreExpr
+                -> [CoreExpr] -> (DmdType, CoreExpr)
+dmdAnalOtherApp env dmd fun args
+  = completeApp env (dmdAnal env call_dmd fun) args
+  where
+    call_dmd = mkCallDmdN (valArgCount args) dmd
+
+----------------
+completeApp :: AnalEnv
+            -> (DmdType, CoreExpr)     -- Function and its demand-type
+            -> [CoreExpr]              -- Arguments
+            -> (DmdType, CoreExpr)     -- Function applied to args
+
+completeApp _ fun_ty_fun []
+  = fun_ty_fun
+completeApp env (fun_ty, fun') (arg:args)
+  | isTypeArg arg = completeApp env (fun_ty,                      App fun' arg)  args
+  | otherwise
+    = -- This case handles value arguments (type args handled above)
+      -- Crucially, coercions /are/ handled here, because they are
+      -- value arguments (Trac #10288)
+    completeApp env (res_ty `bothDmdType` arg_ty, App fun' arg') args
+  where
+    (arg_dmd, res_ty) = splitDmdTy fun_ty
+    (arg_ty, _, arg') = dmdAnalStar env (dmdTransformThunkDmd arg arg_dmd) arg
+
+----------------
+dmdAnalVarApp :: AnalEnv -> CleanDemand -> Id
+              -> [CoreExpr] -> (DmdType, CoreExpr)
+dmdAnalVarApp env dmd fun args
+  | Just con <- isDataConWorkId_maybe fun  -- Data constructor
+  , isVanillaDataCon con
+  , n_val_args == dataConRepArity con      -- Saturated
+  , dataConRepArity con < 10
+  , Just cxt_ds <- splitProdCleanDmd n_val_args dmd
+  , let cpr_info
+          | isProductTyCon (dataConTyCon con) = cprProdDmdType (maxCprDepth (ae_dflags env)) arg_rets
+          | otherwise                         = cprSumDmdType (maxCprDepth (ae_dflags env)) (dataConTag con)
+        res_ty = foldl bothDmdType cpr_info arg_tys
+        (arg_tys, arg_rets, args') = anal_con_args cxt_ds args
+            -- The constructor itself is lazy
+            -- See Note [Data-con worker strictness] in MkId
+  = -- pprTrace "dmdAnalVarApp" (vcat [ ppr con, ppr args, ppr n_val_args, ppr cxt_ds
+    --                                , ppr arg_tys, ppr cpr_info, ppr res_ty]) $
+    ( res_ty
+    , foldl App (Var fun) args')
+  where
+    n_val_args = valArgCount args
+
+    anal_con_args :: [Demand] -> [CoreExpr] -> ([BothDmdArg], [DmdResult], [CoreExpr])
+    anal_con_args _ [] = ([],[],[])
+    anal_con_args ds (arg : args)
+      | isTypeArg arg
+      , (arg_tys, arg_rets, args') <- anal_con_args ds args
+      = (arg_tys, arg_rets, arg:args')
+    anal_con_args (d:ds) (arg : args)
+      | (arg_ty, arg_ret, arg') <- dmdAnalStar env (dmdTransformThunkDmd arg d) arg
+      , (arg_tys, arg_rets, args') <- anal_con_args ds args
+      = (arg_ty:arg_tys, arg_ret:arg_rets, arg':args')
+    anal_con_args ds args = pprPanic "anal_con_args" (ppr args $$ ppr ds)
+
+dmdAnalVarApp env dmd fun args
+  = --pprTrace "dmdAnalVarApp" (vcat [ ppr fun, ppr args
+    --                               , ppr $ completeApp env (dmdTransform env fun (mkCallDmdN n_val_args dmd), Var fun) args
+    --                               ])
+    completeApp env (dmdTransform env fun (mkCallDmdN (valArgCount args) dmd), Var fun) args
 
 {-
 ************************************************************************
@@ -595,8 +713,8 @@
 dmdAnalTrivialRhs ::
     AnalEnv -> Id -> CoreExpr -> Var ->
     (DmdEnv, Id, CoreExpr)
-dmdAnalTrivialRhs env id rhs fn
-  = (fn_fv, set_idStrictness env id fn_str, rhs)
+dmdAnalTrivialRhs env var rhs fn
+  = (fn_fv, set_idStrictness env var fn_str, rhs)
   where
     fn_str = getStrictness env fn
     fn_fv | isLocalId fn = unitVarEnv fn topDmd
@@ -628,30 +746,34 @@
            -> (DmdEnv, Id, CoreExpr)
 -- Process the RHS of the binding, add the strictness signature
 -- to the Id, and augment the environment with the signature as well.
-dmdAnalRhsLetDown top_lvl rec_flag env let_dmd id rhs
+dmdAnalRhsLetDown top_lvl rec_flag env let_dmd var rhs
   | Just fn <- unpackTrivial rhs   -- See Note [Demand analysis for trivial right-hand sides]
-  = dmdAnalTrivialRhs env id rhs fn
+  = dmdAnalTrivialRhs env var rhs fn
 
   | otherwise
-  = (lazy_fv, id', mkLams bndrs' body')
+  = (lazy_fv, var', mkLams bndrs' body')
   where
     (bndrs, body, body_dmd)
-       = case isJoinId_maybe id of
+       = case isJoinId_maybe var of
            Just join_arity  -- See Note [Demand analysis for join points]
                    | (bndrs, body) <- collectNBinders join_arity rhs
                    -> (bndrs, body, let_dmd)
 
            Nothing | (bndrs, body) <- collectBinders rhs
                    -> (bndrs, body, mkBodyDmd env body)
 
-    env_body         = foldl extendSigsWithLam env bndrs
-    (body_ty, body') = dmdAnal env_body body_dmd body
-    body_ty'         = removeDmdTyArgs body_ty -- zap possible deep CPR info
+    env_body             = foldl extendSigsWithLam env bndrs
+    (body_ty, body')     = dmdAnal env_body body_dmd body
+    body_ty'             = removeDmdTyArgs body_ty -- zap possible deep CPR info
     (DmdType rhs_fv rhs_dmds rhs_res, bndrs')
-                     = annotateLamBndrs env (isDFunId id) body_ty' bndrs
-    sig_ty           = mkStrictSig (mkDmdType sig_fv rhs_dmds rhs_res')
-    id'              = set_idStrictness env id sig_ty
-        -- See Note [NOINLINE and strictness]
+                         = annotateLamBndrs env (isDFunId var) body_ty' bndrs
+    sig_ty               = mkStrictSig $
+                           mkDmdType sig_fv rhs_dmds $
+                                handle_sum_cpr $
+                                handle_thunk_cpr $
+                                rhs_res
+    var'                 = set_idStrictness env var sig_ty
+      -- See Note [NOINLINE and strictness]
 
 
     -- See Note [Aggregated demand for cardinality]
@@ -662,16 +784,19 @@
     -- See Note [Lazy and unleashable free variables]
     (lazy_fv, sig_fv) = splitFVs is_thunk rhs_fv1
 
-    rhs_res'  = trimCPRInfo trim_all trim_sums rhs_res
-    trim_all  = is_thunk && not_strict
-    trim_sums = not (isTopLevel top_lvl) -- See Note [CPR for sum types]
+    -- Note [CPR for sum types]
+    handle_sum_cpr | isTopLevel top_lvl = id
+                   | otherwise          = forgetSumCPR
 
     -- See Note [CPR for thunks]
-    is_thunk = not (exprIsHNF rhs) && not (isJoinId id)
+    handle_thunk_cpr | is_thunk && not_strict = forgetCPR
+                     | otherwise              = id
+
+    is_thunk = not (exprIsHNF rhs) && not (isJoinId var)
     not_strict
        =  isTopLevel top_lvl  -- Top level and recursive things don't
        || isJust rec_flag     -- get their demandInfo set at all
-       || not (isStrictDmd (idDemandInfo id) || ae_virgin env)
+       || not (isStrictDmd (idDemandInfo var) || ae_virgin env)
           -- See Note [Optimistic CPR in the "virgin" case]
 
 mkBodyDmd :: AnalEnv -> CoreExpr -> CleanDemand
@@ -875,7 +1000,7 @@
                  Nothing  -> main_ty
                  Just unf -> main_ty `bothDmdType` unf_ty
                           where
-                             (unf_ty, _) = dmdAnalStar env dmd unf
+                             (unf_ty, _, _) = dmdAnalStar env dmd unf
 
     main_ty = addDemand dmd dmd_ty'
     (dmd_ty', dmd) = findBndrDmd env arg_of_dfun dmd_ty id
@@ -908,6 +1033,9 @@
 sums, there may be Nothing alternatives; and that messes
 up the sum-type CPR.
 
+This also applies to nested CPR information: Keep product CPR information, but
+zap sum CPR information therein.
+
 Conclusion: only do this for products.  It's still not
 guaranteed OK for products, but sums definitely lose sometimes.
 
@@ -1152,15 +1280,19 @@
 -- | Extend an environment with the strictness IDs attached to the id
 extendAnalEnvs :: TopLevelFlag -> AnalEnv -> [Id] -> AnalEnv
 extendAnalEnvs top_lvl env vars
-  = env { ae_sigs = extendSigEnvs top_lvl (ae_sigs env) vars }
+  = extendAnalEnvs1 top_lvl env [ (i, idStrictness i) | i <- vars ]
 
-extendSigEnvs :: TopLevelFlag -> SigEnv -> [Id] -> SigEnv
-extendSigEnvs top_lvl sigs vars
-  = extendVarEnvList sigs [ (var, (idStrictness var, top_lvl)) | var <- vars]
+extendAnalEnvs1 :: TopLevelFlag -> AnalEnv -> [(Id, StrictSig)] -> AnalEnv
+extendAnalEnvs1 top_lvl = foldl' (\e (i,s) -> extendAnalEnv top_lvl e i s)
 
 extendAnalEnv :: TopLevelFlag -> AnalEnv -> Id -> StrictSig -> AnalEnv
 extendAnalEnv top_lvl env var sig
-  = env { ae_sigs = extendSigEnv top_lvl (ae_sigs env) var sig }
+  = env { ae_sigs = extendSigEnv top_lvl (ae_sigs env) var sig' }
+  where
+  sig' | isWeakLoopBreaker (idOccInfo var) = sigMayDiverge sig
+             -- Note [Recursion and nested CPR]
+       | isUnliftedType (idType var)       = convergeSig sig
+       | otherwise                         = sig
 
 extendSigEnv :: TopLevelFlag -> SigEnv -> Id -> StrictSig -> SigEnv
 extendSigEnv top_lvl sigs var sig = extendVarEnv sigs var (sig, top_lvl)
@@ -1179,51 +1311,68 @@
 
 extendSigsWithLam :: AnalEnv -> Id -> AnalEnv
 -- Extend the AnalEnv when we meet a lambda binder
-extendSigsWithLam env id
-  | isId id
-  , isStrictDmd (idDemandInfo id) || ae_virgin env
-       -- See Note [Optimistic CPR in the "virgin" case]
-       -- See Note [Initial CPR for strict binders]
-  , Just (dc,_,_,_) <- deepSplitProductType_maybe (ae_fam_envs env) $ idType id
-  = extendAnalEnv NotTopLevel env id (cprProdSig (dataConRepArity dc))
-
+extendSigsWithLam env id =
+  case initialCPRForBinder env id (isStrictDmd (idDemandInfo id)) of
+  Just res ->
+    extendAnalEnv NotTopLevel env id $ sigMayDiverge $
+      mkClosedStrictSig [] res
+  Nothing -> env
+
+initialCPRForBinder :: AnalEnv -> Id -> Bool -> Maybe DmdResult
+initialCPRForBinder env id is_strict
+  | not (isId id)
+  = Nothing
+  | ae_virgin env
+     -- See Note [Optimistic CPR in the "virgin" case]
+  = Just $ nestedCPRResultForType env (idType id)
+  | is_strict
+     -- See Note [Initial CPR for strict binders]
+  = Just $ forgetLazyCPR (getStrDmd (idDemandInfo id)) $
+      nestedCPRResultForType env (idType id)
   | otherwise
-  = env
+  = Nothing
+
+nestedCPRResultForType :: AnalEnv -> Type -> DmdResult
+nestedCPRResultForType env = go
+  where
+    go ty
+      | Just (_, _, arg_tys, _)
+          <- deepSplitProductType_maybe (ae_fam_envs env) ty
+      = cprProdRes' $ map (go . fst) arg_tys
+      | otherwise
+      = topRes
 
 extendEnvForProdAlt :: AnalEnv -> CoreExpr -> Id -> DataCon -> [Var] -> AnalEnv
 -- See Note [CPR in a product case alternative]
 extendEnvForProdAlt env scrut case_bndr dc bndrs
-  = foldl do_con_arg env1 ids_w_strs
+  | Just v <- unwrap_var scrut
+  = extendEnvForProdAltVar env v case_bndr dc bndrs
+  | otherwise
+  = extendAnalEnv NotTopLevel env case_bndr $
+    cprProdSig (maxCprDepth (ae_dflags env)) $
+    replicate (dataConRepArity dc) topRes
   where
-    env1 = extendAnalEnv NotTopLevel env case_bndr case_bndr_sig
+    unwrap_var (Cast e _) = unwrap_var e
+    unwrap_var (Var v)    = Just v
+    unwrap_var _          = Nothing
+
 
-    ids_w_strs    = filter isId bndrs `zip` dataConRepStrictness dc
-    case_bndr_sig = cprProdSig (dataConRepArity dc)
-    fam_envs      = ae_fam_envs env
-
-    do_con_arg env (id, str)
-       | let is_strict = isStrictDmd (idDemandInfo id) || isMarkedStrict str
-       , ae_virgin env || (is_var_scrut && is_strict)  -- See Note [CPR in a product case alternative]
-       , Just (dc,_,_,_) <- deepSplitProductType_maybe fam_envs $ idType id
-       = extendAnalEnv NotTopLevel env id (cprProdSig (dataConRepArity dc))
-       | otherwise
-       = env
-
-    is_var_scrut = is_var scrut
-    is_var (Cast e _) = is_var e
-    is_var (Var v)    = isLocalId v
-    is_var _          = False
-
-addDataConStrictness :: DataCon -> [Demand] -> [Demand]
--- See Note [Add demands for strict constructors]
-addDataConStrictness con ds
-  = ASSERT2( equalLength strs ds, ppr con $$ ppr strs $$ ppr ds )
-    zipWith add ds strs
+extendEnvForProdAltVar :: AnalEnv -> Id -> Id -> DataCon -> [Var] -> AnalEnv
+extendEnvForProdAltVar env scrut_var case_bndr dc bndrs
+  = foldl' add_result env1 $ zip ids results
   where
-    strs = dataConRepStrictness con
-    add dmd str | isMarkedStrict str
-                , not (isAbsDmd dmd) = dmd `bothDmd` seqDmd
-                | otherwise          = dmd
+    add_result env (id, res)
+      | isTopRes res = env
+      | otherwise = extendAnalEnv NotTopLevel env id (mkClosedStrictSig [] res)
+    env1 = extendAnalEnv NotTopLevel env case_bndr case_bndr_sig
+
+    results       = take (dataConRepArity dc) $ splitNestedRes $
+        case lookupSigEnv env scrut_var of
+      Nothing -> topRes
+      Just (sig, _toplevel) -> snd $ splitStrictSig sig
+
+    ids           = filter isId bndrs
+    case_bndr_sig = cprProdSig (maxCprDepth (ae_dflags env)) results
 
 findBndrsDmds :: AnalEnv -> DmdType -> [Var] -> (DmdType, [Demand])
 -- Return the demands on the Ids in the [Var]
@@ -1459,6 +1608,9 @@
     f4 (MkT4 x@(Foo v) y) | y>0       = f4 (MkT4 x (y-1))
                           | otherwise = v
 
+And finally note that the signature should obviously _not_ claim that it is
+converging (like a constructor call would).
+
 
 Note [Initialising strictness]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -1526,4 +1678,43 @@
 duplicating actual function calls.
 
 Also see #11731.
+
+Note [Recursion and nested cpr]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+In extendAnalEnv, we remove possible definite convergence information from loop
+breakers.
+
+This is *not* required to make termination analysis sound: It would be fine
+without this, since we initialize the fixed point iteration with definite
+divergence, and this is sufficient to make sure that, for example, a
+tail-recursive function is not going to be considered terminating.
+
+But we need to do it to avoid the nested CPR w/w-transformation from going
+horribly wrong. Consider this code (also in tests/stranal/sigs/StreamSig.hs):
+
+    data Stream a = Stream a (Stream a)
+    forever :: a -> Stream a
+    forever x = Stream x (forever x)
+
+This should deserve a CPR information of
+
+   tm(,tm(,))
+
+(or deeper, as you wish) because clearly it terminates arbitrarily deep. But if
+we gave it that signature, we would generate the following worker:
+
+  $wforever x = case $wforever x of
+    (# ww1, ww2, ww3 #) -> (# x, ww1, Stream ww2 ww3 #)
+
+which will obviously diverge. By killing the convergence flag for loop breakers
+we ensure that the CPR information is
+
+   tm(,m(,))
+
+and the worker is
+
+  $wforever x = (# x, case $wforever x of (# a, b#) -> Stream a b #)
+
+which is fine (and will later be further simplified).
 -}
diff --git a/compiler/stranal/WorkWrap.hs b/compiler/stranal/WorkWrap.hs
--- a/compiler/stranal/WorkWrap.hs
+++ b/compiler/stranal/WorkWrap.hs
@@ -560,7 +560,7 @@
                   | otherwise      = res_info
     work_res_info | isJoinId fn_id = res_info -- Worker remains CPR-able
                   | otherwise
-                  = case returnsCPR_maybe res_info of
+                  = case returnsCPR_maybe False res_info of
                        Just _  -> topRes    -- Cpr stuff done by wrapper; kill it here
                        Nothing -> res_info  -- Preserve exception/divergence
 
diff --git a/compiler/stranal/WwLib.hs b/compiler/stranal/WwLib.hs
--- a/compiler/stranal/WwLib.hs
+++ b/compiler/stranal/WwLib.hs
@@ -21,8 +21,7 @@
 import IdInfo           ( JoinArity, vanillaIdInfo )
 import DataCon
 import Demand
-import MkCore           ( mkAbsentErrorApp, mkCoreUbxTup
-                        , mkCoreApp, mkCoreLet )
+import MkCore
 import MkId             ( voidArgId, voidPrimId )
 import TysWiredIn       ( tupleDataCon )
 import TysPrim          ( voidPrimTy )
@@ -44,6 +43,8 @@
 import FastString
 import ListSetOps
 
+import Control.Monad   ( zipWithM )
+
 {-
 ************************************************************************
 *                                                                      *
@@ -717,7 +718,7 @@
   | let (co, ty1) = topNormaliseType_maybe fam_envs ty
                     `orElse` (mkRepReflCo ty, ty)
   , Just (tc, tc_args) <- splitTyConApp_maybe ty1
-  , isDataTyCon tc
+  , isDataTyCon tc || isUnboxedTupleTyCon tc
   , let cons = tyConDataCons tc
   , cons `lengthAtLeast` con_tag -- This might not be true if we import the
                                  -- type constructor via a .hs-bool file (#8743)
@@ -773,56 +774,91 @@
                    CoreExpr -> CoreExpr,     -- New wrapper
                    CoreExpr -> CoreExpr,     -- New worker
                    Type)                     -- Type of worker's body
-
 mkWWcpr opt_CprAnal fam_envs body_ty res
     -- CPR explicitly turned off (or in -O0)
   | not opt_CprAnal = return (False, id, id, body_ty)
     -- CPR is turned on by default for -O and O2
   | otherwise
-  = case returnsCPR_maybe res of
-       Nothing      -> return (False, id, id, body_ty)  -- No CPR info
-       Just con_tag | Just stuff <- deepSplitCprType_maybe fam_envs con_tag body_ty
-                    -> mkWWcpr_help stuff
-                    |  otherwise
-                       -- See Note [non-algebraic or open body type warning]
-                    -> WARN( True, text "mkWWcpr: non-algebraic or open body type" <+> ppr body_ty )
-                       return (False, id, id, body_ty)
-
-mkWWcpr_help :: (DataCon, [Type], [(Type,StrictnessMark)], Coercion)
-             -> UniqSM (Bool, CoreExpr -> CoreExpr, CoreExpr -> CoreExpr, Type)
-
-mkWWcpr_help (data_con, inst_tys, arg_tys, co)
-  | [arg1@(arg_ty1, _)] <- arg_tys
-  , isUnliftedType arg_ty1
-        -- Special case when there is a single result of unlifted type
-        --
-        -- Wrapper:     case (..call worker..) of x -> C x
-        -- Worker:      case (   ..body..    ) of C x -> x
-  = do { (work_uniq : arg_uniq : _) <- getUniquesM
-       ; let arg       = mk_ww_local arg_uniq arg1
-             con_app   = mkConApp2 data_con inst_tys [arg] `mkCast` mkSymCo co
-
-       ; return ( True
-                , \ wkr_call -> Case wkr_call arg (exprType con_app) [(DEFAULT, [], con_app)]
-                , \ body     -> mkUnpackCase body co work_uniq data_con [arg] (varToCoreExpr arg)
+  = do help_stuff <- mkWWcpr_help fam_envs False body_ty res
+       case help_stuff of
+        Nothing -> return (False, id, id, body_ty)
+
+         -- When we have to wrap only one argument, and it is unlifted,
+         -- skip the (# .. #)
+         -- (Would be wrong for non-lifted arguments!)
+        Just ([arg_var], con_app, decon) | isUnliftedType (idType arg_var) -> do
+           return ( True
+                  , \ wkr_call -> mkRename wkr_call arg_var con_app
+                  , \ body     -> decon body (varToCoreExpr arg_var)
                                 -- varToCoreExpr important here: arg can be a coercion
                                 -- Lacking this caused Trac #10658
-                , arg_ty1 ) }
-
-  | otherwise   -- The general case
-        -- Wrapper: case (..call worker..) of (# a, b #) -> C a b
-        -- Worker:  case (   ...body...  ) of C a b -> (# a, b #)
-  = do { (work_uniq : wild_uniq : uniqs) <- getUniquesM
-       ; let wrap_wild   = mk_ww_local wild_uniq (ubx_tup_ty,MarkedStrict)
-             args        = zipWith mk_ww_local uniqs arg_tys
-             ubx_tup_ty  = exprType ubx_tup_app
-             ubx_tup_app = mkCoreUbxTup (map fst arg_tys) (map varToCoreExpr args)
-             con_app     = mkConApp2 data_con inst_tys args `mkCast` mkSymCo co
-
-       ; return (True
-                , \ wkr_call -> Case wkr_call wrap_wild (exprType con_app)  [(DataAlt (tupleDataCon Unboxed (length arg_tys)), args, con_app)]
-                , \ body     -> mkUnpackCase body co work_uniq data_con args ubx_tup_app
-                , ubx_tup_ty ) }
+                  , idType arg_var )
+
+        Just (arg_vars, con_app, decon) -> do
+           wrap_wild_uniq <- getUniqueM
+
+           let wrap_wild = mk_ww_local wrap_wild_uniq (ubx_tup_ty,MarkedStrict)
+               arg_tys = map idType arg_vars
+               ubx_tup_app  = mkCoreUbxTup arg_tys (map varToCoreExpr arg_vars)
+               ubx_tup_ty   = exprType ubx_tup_app
+
+           return ( True
+                  , \ wkr_call -> Case wkr_call wrap_wild (exprType con_app)  [(DataAlt (tupleDataCon Unboxed (length arg_tys)), arg_vars, con_app)]
+                  , \ body     -> decon body ubx_tup_app
+                  , ubx_tup_ty )
+
+{-
+Explanation of mkWWcpr_help's return type:
+
+Nothing:   There is nothing worth taking apart.
+           On the outer level, this will prevent mkWWcpr from doing anything at all
+           Otherwise it means: Use the value directly
+Just (vars, con_app, decon):
+  vars:    Variables used when deconstructing/constructing boxed values
+  con_app: Assuming those variables are in scope, wraps them in the constructor
+  decon:   Takes the constructor returned by the first argument apart, binds
+           its parameters to `vars`, and in that scope executes the second argument.
+-}
+mkWWcpr_help :: FamInstEnvs -> Bool ->  -- Is this an inner call?
+                Type -> DmdResult -> UniqSM (Maybe ([Var], CoreExpr, CoreExpr -> CoreExpr -> CoreExpr))
+mkWWcpr_help fam_envs inner ty res = case returnsCPR_maybe inner res of
+    Just (con_tag, rs)
+        | Just (data_con, inst_tys, arg_tys, co) <- deepSplitCprType_maybe fam_envs con_tag ty
+        -> do uniq1:arg_uniqs <- getUniquesM
+              let arg_vars = zipWith mk_ww_local arg_uniqs arg_tys
+
+              maybe_arg_stuff <- zipWithM (mkWWcpr_help fam_envs True)
+                  (map fst arg_tys) (rs ++ repeat topRes)
+
+              let go_arg_stuff var Nothing
+                    = ([var], varToCoreExpr var, id) -- this argument does not need to be deconstructed further
+                  go_arg_stuff var (Just (inner_vars, arg_con, arg_decon))
+                    = (inner_vars, arg_con, arg_decon (varToCoreExpr var))
+
+              let (inner_arg_varss, arg_cons, arg_decons) = unzip3 $ zipWith go_arg_stuff arg_vars maybe_arg_stuff
+                  inner_arg_vars = concat        inner_arg_varss
+                  inner_decon    = foldr (.) id  arg_decons
+
+              if isUnboxedTupleCon data_con && all isNothing maybe_arg_stuff
+                then return Nothing
+                else return $ Just
+                    ( inner_arg_vars
+                    , mkConApp data_con (map Type inst_tys ++ arg_cons) `mkCast` mkSymCo co
+                    , \e body -> mkUnpackCase e co uniq1 data_con arg_vars (inner_decon body)
+                    )
+        |  otherwise
+        -> -- See Note [non-algebraic or open body type warning]
+           WARN ( True, ptext (sLit "mkWwcpr: non-algebraic or open body type") <+>
+                              (ppr ty) <+> ptext (sLit "but CPR type") <+> ppr (res) )
+           mkWWcpr_help fam_envs inner ty topRes
+    Nothing -> return Nothing
+
+mkRename :: CoreExpr -> Var -> CoreExpr -> CoreExpr
+-- mkRename e v body
+-- binds v to e in body. This will later be removed by the simplifiers
+mkRename e v (Var v') | v == v' = e
+mkRename e v body = ASSERT( idType v `eqType` exprType e)
+                    mkCoreLet (NonRec v e) body
 
 mkUnpackCase ::  CoreExpr -> Coercion -> Unique -> DataCon -> [Id] -> CoreExpr -> CoreExpr
 -- (mkUnpackCase e co uniq Con args body)
diff --git a/docs/nested-cpr/nested-cpr.tex b/docs/nested-cpr/nested-cpr.tex
new file mode 100644
--- /dev/null
+++ b/docs/nested-cpr/nested-cpr.tex
@@ -0,0 +1,276 @@
+\documentclass[parskip=half]{scrartcl}
+
+\usepackage[T1]{fontenc}
+\usepackage[safe]{tipa} % for \textlambda
+\usepackage[utf8]{inputenc}
+\usepackage[english]{babel}
+\usepackage{etex}
+\usepackage{stmaryrd}
+\usepackage{amsmath}
+\usepackage{amsfonts}
+\usepackage{amssymb}
+\usepackage{mathtools}
+%\usepackage[amsmath,thmmarks]{ntheorem}
+\usepackage[numbers]{natbib}
+\usepackage{mathpazo}
+% Causes problems with MikTeX
+%\usepackage{microtype}
+\usepackage{booktabs}
+\usepackage{mathpartir}
+\usepackage{upgreek}
+\usepackage{enumerate}
+\usepackage{paralist}
+\usepackage{textcomp}
+\usepackage{xcolor}
+
+\usepackage{hyperref}
+
+\urlstyle{sf}
+\makeatletter
+% Inspired by http://anti.teamidiot.de/nei/2009/09/latex_url_slash_spacingkerning/
+% but slightly less kern and shorter underscore
+\let\UrlSpecialsOld\UrlSpecials
+\def\UrlSpecials{\UrlSpecialsOld\do\/{\Url@slash}\do\_{\Url@underscore}}%
+\def\Url@slash{\@ifnextchar/{\kern-.11em\mathchar47\kern-.2em}%
+   {\kern-.0em\mathchar47\kern-.08em\penalty\UrlBigBreakPenalty}}
+\def\Url@underscore{\nfss@text{\leavevmode \kern.06em\vbox{\hrule\@width.3em}}}
+\makeatother
+
+%\theorembodyfont{}
+%\newtheorem{theorem}{Theorem}
+%\newtheorem{lemma}[theorem]{Lemma}
+%\theoremstyle{nonumberplain}
+%\theoremheaderfont{\scshape}
+%\theoremsymbol{\ensuremath{\blacksquare}}
+%\theoremseparator{.}
+%\newtheorem{proof}{Proof}
+
+\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}
+
+\usepackage{listings}
+\newcommand{\li}{\lstinline[style=Haskell]}
+\lstnewenvironment{haskell}{\lstset{style=Haskell}}{}
+\lstdefinestyle{Haskell}{language=Haskell
+        ,columns=flexible
+	,basewidth={.365em}
+	,keepspaces=True
+        ,texcl=true
+%        ,escapechar=!
+        ,basicstyle=\sffamily
+        ,stringstyle=\itshape
+        ,showstringspaces=false
+        ,literate={->}{$\,\to\,$}2
+                  {<-}{$\,\leftarrow\,$}2
+                  {=>}{$\,\Rightarrow\,$}2
+                  {â†’}{$\,\to\,$}2
+%                  {\\}{\textlambda}1
+                  {>>}{{>>}\hspace{-1pt}}2
+%                  {+}{{$+$}}1
+                  {[]}{[\,]\ }1
+%                  {--}{{---\ }}1
+                  {++}{{$+\!\!+$}}1
+%                 {\ .}{{$\,\circ\,$}}2
+                  {\ .\ }{{$\,\circ\,$}}2
+                  {~}{{$\sim$}}1 % hack
+                  {|>}{{$\triangleright$}}1 % hack
+	,keywords={%
+	    case,class,data,default,deriving,do,else,%
+	    foreign,if,import,in,infix,infixl,infixr,instance,%
+	    let,forall,letrec,module,newtype,role,of,then,type,where,\_,%
+	}
+        }
+
+\newcommand{\sIde}{\text{Ide}}
+\newcommand{\sExp}{\text{Exp}}
+\newcommand{\sEnv}{\text{Env}}
+
+\newcommand{\sem}[2]{\llbracket #1\rrbracket #2}
+
+\newcommand{\sApp}[2]{#1\,#2}
+\newcommand{\sLam}[2]{\text{\textlambda} #1.\, #2}
+\newcommand{\sCase}[4]{\text{\textsf{case}}\ #1\  \textsf{as}\ #2\ \textsf{of}\ \{#3 \rightarrow #4\}_{i=1}^n}
+\newcommand{\sPCase}[4]{\text{\textsf{case}}\ #1\  \textsf{as}\ #2\ \textsf{of}\ \{#3 \rightarrow #4\}}
+\newcommand{\sLet}[3]{\text{\textsf{let}}\ \{#1 = #2\}_{i=1}^n\ \text{\textsf{in}}\ #3}
+
+\newcommand{\both}[2]{#1\mathbin{\&}#2}
+
+
+\title{Constructd Product Result Analysis -- nested}
+\author{Joachim Breitner}
+
+\begin{document}
+\maketitle
+% \allowdisplaybreaks[1]
+
+\begin{abstract}
+Since many years, GHC is able to optimize functions returning product types by allowing them to return multiple values. We enhance this transformation to nested products, which in turn requires a small termination analysis.
+
+This paper describes the analysis and transformation. It can be considered an extension of \citep{cpr}.
+\end{abstract}
+
+\tableofcontents
+
+\section{The language}
+
+Just like in \citep{cpr}, we present the analysis with regard to a core language that does not involve type annotations, our expressions are of the form:
+%
+\begin{align*}
+x \colon \sIde \\
+e \colon \sExp &\Coloneqq x
+	\mid \sLam x e
+	\mid \sApp {e_1} {e_2}
+	\mid \sApp C {e_1\ldots e_n} \\
+&	\mid \sCase e x {\sApp {C_i} {e_{1_i}\ldots e_{n_i}}} {e_i}
+	\mid \sLet {x_i} {e_i} e
+\end{align*}
+
+\section{The abstract domain}
+
+With nested CPR, we need to know two things about a value:
+\begin{itemize}
+\item Does it return construct and return a data constructor, and
+\item does it so for sure (and without side-effects, which are not modelled in this section).
+\end{itemize}
+
+\newcommand{\dR}{\textbf{R}}
+\newcommand{\dC}{\textbf{C}}
+\newcommand{\dD}{\textbf{D}}
+\newcommand{\noCPR}{\bullet}
+\newcommand{\dunno}[1]{#1?}
+\newcommand{\conv}[1]{#1!}
+\newcommand{\dLam}[1]{(\sLam\bullet{#1})}
+\newcommand{\dApp}[1]{\sApp{#1}\bullet}
+
+In particular, we will need to know this about the parameters of a returned constructor. Therefore, our analysis works with a domain described by these equations:
+\begin{align*}
+\dR \Coloneqq{} & \bot && \text{definite divergence}\\
+\mid{} &\dunno{\dC} && \text{potential convergence}\\
+\mid{} &\conv{\dC} && \text{definite convergence}\\
+\dC \Coloneqq{} & \noCPR && \text{no information about the returned value} \\
+\mid{} & (\dR,\ldots, \dR) && \text{returns a constructed product}
+\end{align*}
+
+We will actually need two different partial orders on $\dR$, one being the refinement of the other. The finer one, $\sqsubseteq$, is generated by the relations
+\begin{itemize}
+\item $\bot \sqsubset \dunno c$,
+\item $\conv{c} \sqsubset \dunno c$,
+\item $(r_1,\ldots, r_n) \sqsubset \noCPR$
+\end{itemize}
+and by mapping $\dunno\cdot$, $\conv\cdot$ and $(\cdot,\ldots,\cdot)$ over relations. The element $\noCPR$ is the top element of $\dC$; $\dunno\noCPR$ the top of $\dR$. There is no bottom element in this partial order.
+
+In the coarser relation $\sqsubseteq'$, we additionally have $\bot \sqsubset' \conv c$. This way, this partial order has a least element.
+
+In slight abuse of notation, $\conv{\cdot} \colon \dR \to\dR$ sets the convergence flag
+\begin{align*}
+\conv{\bot} &= \bot \\
+\conv{\conv{c}} &= \conv{c} \\
+\conv{\dunno{c}} &= \conv{c}
+\end{align*}
+
+The operation $\both{\cdot}{\cdot} \colon \dR \to \dR \to \dR$ adjusts the termination information of the first value based on that of the second:
+\begin{align*}
+\both{\bot}r &= \bot \\
+\both r{\bot} &= \bot \\
+\both{\conv{c_1}}{\conv{c_2}} &= \conv{c_1} \\
+\both{\conv{c_1}}{\dunno{c_2}} &= \dunno{c_1} \\
+\both{\dunno{c_1}}{\conv{c_2}} &= \dunno{c_1} \\
+\both{\dunno{c_1}}{\dunno{c_2}} &= \dunno{c_1}
+\end{align*}
+
+There is a projection operation $\pi_i \colon \dC \to \dR$, defined by
+\begin{align*}
+\pi_i(r_1,\ldots,r_n) &=
+\begin{cases}
+\pi_i (r) & \text{for $1 \le i \le n$}\\
+\dunno\noCPR & \text{otherwise}
+\end{cases}\\
+\pi_i(\noCPR) &= \dunno\noCPR,
+\end{align*}
+and lifted to $\dR$ by
+\begin{align*}
+\pi_i(\bot) &= \dunno\noCPR\\
+\pi_i(\dunno c) &= \pi_i(c) \\
+\pi_i(\conv c) &= \pi_i(c).
+\end{align*}
+
+Furthermore, for functions, we additionally need to know their arity. Conceptually, this yields the product domain $\dD=(\mathbb N, \dR)$, where $\mathbb N$ is descretely ordered, but in analogy to \citep{cpr}, we write
+\begin{align*}
+\dD \Coloneqq \dR \mid \dLam\dD.
+\end{align*}
+Decreasing the arity of $d$ is written $\dApp d$, in analogy to function application, and defined by
+\begin{align*}
+\dApp{\dLam d} = d\\
+\dApp{r} = \dunno\noCPR
+\end{align*}
+The projection operation is also lifted to $\dD$:
+\begin{align*}
+\pi_i\dLam{d} &= \dunno\noCPR\\
+\pi_i(r) &= \pi_i(r) \\
+\end{align*}
+
+
+An environment is a function from identifiers to abstract values:
+\begin{align*}
+\rho \colon \sExp = \sIde \to \dD.
+\end{align*}
+
+\section{The analysis}
+
+So our analysis is a function $\sem{\cdot}\cdot \colon \sExp \to \sEnv \to \dD$, defined as follows:
+%
+\newcommand{\upd}[3]{#1[#2 \mapsto #3]}
+%
+\begin{align*}
+\sem{x}\rho &= \sApp \rho x \\
+\sem{\sLam x e}\rho &= \dLam{\sem e{\upd\rho x{\dunno\noCPR}}} \\
+\sem{\sApp {e_1} {e_2}}\rho &= \dApp{(\sem{e_1}\rho)} \\
+\sem{\sApp C {e_1\ldots e_n}}\rho &= \conv{(\sem{e_1}\rho, \ldots, \sem{e_n}\rho)} \\
+\sem{\sLet {x_i}{e_i} e}\rho &= \sem{e}({\mu \rho'. \upd\rho{x_i}{\sem{e_i}{\rho'}}_{i=1}^n})\\
+\sem{\sPCase e x {\sApp C {x_1}\ldots x_n} {e'}}\rho
+	&= \both{
+	     \sem{e'}{
+		\upd{\upd\rho{x_i}{r_i}_{i=1}^{n}}}
+		    {x}{\conv{(r_1,\ldots,r_{n_i})}}
+	   }r\\
+	   &\quad\quad \text{where }r \coloneqq \sem e\rho, r_i \coloneqq  \pi_i(r)\\
+\sem{\sCase e x {\sApp {C_i} {x_{1_i}\ldots x_{n_i}}} {e_i}}\rho
+	&= \both{\left(
+	     \bigsqcup_{i=1}^n \sem{e_i}{
+		\upd{\upd\rho{x_{i_j}}{\dunno\noCPR}_{j=1}^{n_i}}
+		    {x}{\conv{(\dunno\noCPR,\ldots,\dunno\noCPR)}}}
+	   \right)}r \\
+	   &\quad\quad \text{where } n > 1, r \coloneqq \sem e\rho
+\end{align*}
+
+The equation for variables is straight forward: We just use the data in the environment.
+
+The result of a lambda expression carries the same information as the body, but guarded by $\dLam \cdot$, indicating that this result information will hold if the expression is applied to one argument.
+
+The equation for application is the counterpart: Igoring the second argument, this unwraps one level of $\dLam \cdot$.
+
+A constructor application trivially has a CPR property, and is converging for sure. Therefore, we return that information, and further analyse the components.
+
+The fixed-point operator $(\mu \rho'. f \rho')$ used for recursive lets operates in the coarser partial order $\sqsubseteq'$. In particular
+\[
+(\mu \rho'. f \rho') = {\bigsqcup_{i=0}^\infty}' f^i(\bot)
+\]
+but not necessarily
+\[
+(\mu \rho'. f \rho') = \bigsqcup_{i=0}^\infty f^i(\bot).
+\]
+But this formal technicality has no practical consequences.
+
+For case expressions we use two variants: One for product data type, i.e. those with exactly one constructor, and one general. There are a few things happening here
+\begin{itemize}
+\item In the product type's case, we can use any nested CPR information from the scrunitee to put more information about the case binder and pattern match information into the environment.
+\item The information on the case binder contains at least that it is surely terminating, and an already evaluated constructor. It is not guaranteed that this constructor comes from the current scope, but we want to consider it that way.
+\item Otherwise, nothing is known ($\dunno{\noCPR}$) about the pattern match variables and the components of the case binder.
+\item When there are multiple branches, we combine their information using the least upper bound operator.
+\item And finally we need to mix in the termination information of $e$, using the operator $\&$: The whole expression will only surely terminate if both the scrunitee and all branches are surely terminating.
+\end{itemize}
+
+
+
+
+
+\end{document}
diff --git a/docs/users_guide/using-optimisation.rst b/docs/users_guide/using-optimisation.rst
--- a/docs/users_guide/using-optimisation.rst
+++ b/docs/users_guide/using-optimisation.rst
@@ -45,7 +45,7 @@
 your program needs to be recompiled when you change something. This is
 one reason to stick to no-optimisation when developing code.
 
-**No ``-O*``-type option specified:** This is taken to mean â€œPlease 
+**No ``-O*``-type option specified:** This is taken to mean â€œPlease
 compile quickly; I'm not over-bothered about compiled-code quality.â€
 So, for example, ``ghc -c Foo.hs``
 
@@ -227,6 +227,14 @@
 
     Turn on CPR analysis in the demand analyser.
 
+.. ghc-flag:: -fcpr-depth=âŸ¨nâŸ©
+    :shortdesc: Set the depth of nested CPR.
+    :type: dynamic
+    :default: 3
+
+    Analyze the result of functions for constructed product results to that depth.
+    Setting this to zero disables CPR, setting this to one disables nested CPR.
+
 .. ghc-flag:: -fcse
     :shortdesc: Enable common sub-expression elimination. Implied by :ghc-flag:`-O`.
     :type: dynamic
diff --git a/libraries/base/GHC/Float.hs b/libraries/base/GHC/Float.hs
--- a/libraries/base/GHC/Float.hs
+++ b/libraries/base/GHC/Float.hs
@@ -565,6 +565,7 @@
     floatDigits _       =  DBL_MANT_DIG     -- ditto
     floatRange _        =  (DBL_MIN_EXP, DBL_MAX_EXP) -- ditto
 
+    {-# INLINE decodeFloat #-}
     decodeFloat (D# x#)
       = case decodeDoubleInteger x#   of
           (# i, j #) -> (i, I# j)
diff --git a/testsuite/tests/deSugar/should_compile/T2431.stderr b/testsuite/tests/deSugar/should_compile/T2431.stderr
--- a/testsuite/tests/deSugar/should_compile/T2431.stderr
+++ b/testsuite/tests/deSugar/should_compile/T2431.stderr
@@ -7,10 +7,9 @@
 T2431.$WRefl [InlPrag=INLINE[2]] :: forall a. a :~: a
 [GblId[DataConWrapper],
  Caf=NoCafRefs,
- Str=m,
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
-         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
+         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
          Tmpl= \ (@ a) ->
                  T2431.Refl @ a @ a @~ (<a>_N :: (a :: *) GHC.Prim.~# (a :: *))}]
 T2431.$WRefl
diff --git a/testsuite/tests/numeric/should_compile/T7116.stdout b/testsuite/tests/numeric/should_compile/T7116.stdout
--- a/testsuite/tests/numeric/should_compile/T7116.stdout
+++ b/testsuite/tests/numeric/should_compile/T7116.stdout
@@ -7,41 +7,43 @@
 T7116.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T7116.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7116.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7116.$trModule3 = GHC.Types.TrNameS T7116.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T7116.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T7116.$trModule2 = "T7116"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7116.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7116.$trModule1 = GHC.Types.TrNameS T7116.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T7116.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T7116.$trModule
@@ -52,7 +54,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
@@ -69,7 +71,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
@@ -82,7 +84,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
@@ -101,7 +103,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
diff --git a/testsuite/tests/simplCore/should_compile/T13143.stderr b/testsuite/tests/simplCore/should_compile/T13143.stderr
--- a/testsuite/tests/simplCore/should_compile/T13143.stderr
+++ b/testsuite/tests/simplCore/should_compile/T13143.stderr
@@ -27,41 +27,43 @@
 T13143.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T13143.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T13143.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T13143.$trModule3 = GHC.Types.TrNameS T13143.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T13143.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T13143.$trModule2 = "T13143"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T13143.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T13143.$trModule1 = GHC.Types.TrNameS T13143.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T13143.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T13143.$trModule
@@ -97,7 +99,7 @@
 g [InlPrag=NOUSERINLINE[0]] :: Bool -> Bool -> Int -> Int
 [GblId,
  Arity=3,
- Str=<S,1*U><S,1*U><S(S),1*U(U)>m,
+ Str=<S,1*U><S,1*U><S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
diff --git a/testsuite/tests/simplCore/should_compile/T3717.stderr b/testsuite/tests/simplCore/should_compile/T3717.stderr
--- a/testsuite/tests/simplCore/should_compile/T3717.stderr
+++ b/testsuite/tests/simplCore/should_compile/T3717.stderr
@@ -7,41 +7,43 @@
 T3717.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T3717.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T3717.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T3717.$trModule3 = GHC.Types.TrNameS T3717.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T3717.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T3717.$trModule2 = "T3717"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T3717.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T3717.$trModule1 = GHC.Types.TrNameS T3717.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T3717.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T3717.$trModule
@@ -65,7 +67,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(1*U)>m,
+ Str=<S(S),1*U(1*U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
diff --git a/testsuite/tests/simplCore/should_compile/T3772.stdout b/testsuite/tests/simplCore/should_compile/T3772.stdout
--- a/testsuite/tests/simplCore/should_compile/T3772.stdout
+++ b/testsuite/tests/simplCore/should_compile/T3772.stdout
@@ -1,87 +1,94 @@
 
 ==================== Tidy Core ====================
 Result size of Tidy Core
-  = {terms: 43, types: 18, coercions: 0, joins: 0/0}
+  = {terms: 46, types: 19, coercions: 0, joins: 0/0}
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T3772.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T3772.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T3772.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T3772.$trModule3 = GHC.Types.TrNameS T3772.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T3772.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T3772.$trModule2 = "T3772"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T3772.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T3772.$trModule1 = GHC.Types.TrNameS T3772.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T3772.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T3772.$trModule
   = GHC.Types.Module T3772.$trModule3 T3772.$trModule1
 
 Rec {
 -- RHS size: {terms: 10, types: 2, coercions: 0, joins: 0/0}
-$wxs :: GHC.Prim.Int# -> ()
-[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>]
+$wxs :: GHC.Prim.Int# -> (# #)
+[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m()]
 $wxs
   = \ (ww :: GHC.Prim.Int#) ->
       case ww of ds1 {
         __DEFAULT -> $wxs (GHC.Prim.-# ds1 1#);
-        1# -> GHC.Tuple.()
+        1# -> GHC.Prim.(##)
       }
 end Rec }
 
 -- RHS size: {terms: 10, types: 2, coercions: 0, joins: 0/0}
-T3772.$wfoo [InlPrag=NOINLINE] :: GHC.Prim.Int# -> ()
-[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>]
+T3772.$wfoo [InlPrag=NOINLINE] :: GHC.Prim.Int# -> (# #)
+[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>m()]
 T3772.$wfoo
   = \ (ww :: GHC.Prim.Int#) ->
       case GHC.Prim.<# 0# ww of {
-        __DEFAULT -> GHC.Tuple.();
+        __DEFAULT -> GHC.Prim.(##);
         1# -> $wxs ww
       }
 
--- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
+-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
 foo [InlPrag=NOUSERINLINE[0]] :: Int -> ()
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>,
+ Str=<S(S),1*U(U)>m(),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
          Tmpl= \ (w [Occ=Once!] :: Int) ->
-                 case w of { GHC.Types.I# ww1 [Occ=Once] -> T3772.$wfoo ww1 }}]
+                 case w of { GHC.Types.I# ww1 [Occ=Once] ->
+                 case T3772.$wfoo ww1 of { (# #) -> GHC.Tuple.() }
+                 }}]
 foo
-  = \ (w :: Int) -> case w of { GHC.Types.I# ww1 -> T3772.$wfoo ww1 }
+  = \ (w :: Int) ->
+      case w of { GHC.Types.I# ww1 ->
+      case T3772.$wfoo ww1 of { (# #) -> GHC.Tuple.() }
+      }
 
 
 
diff --git a/testsuite/tests/simplCore/should_compile/T4201.stdout b/testsuite/tests/simplCore/should_compile/T4201.stdout
--- a/testsuite/tests/simplCore/should_compile/T4201.stdout
+++ b/testsuite/tests/simplCore/should_compile/T4201.stdout
@@ -1,3 +1,3 @@
-  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U()>m,
+  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U()>m(),
      Unfolding: InlineRule (0, True, True)
                 bof `cast` (Sym (N:Foo[0]) ->_R <T>_R) -}
diff --git a/testsuite/tests/simplCore/should_compile/T4908.stderr b/testsuite/tests/simplCore/should_compile/T4908.stderr
--- a/testsuite/tests/simplCore/should_compile/T4908.stderr
+++ b/testsuite/tests/simplCore/should_compile/T4908.stderr
@@ -1,104 +1,125 @@
 
 ==================== Tidy Core ====================
 Result size of Tidy Core
-  = {terms: 68, types: 43, coercions: 0, joins: 0/0}
+  = {terms: 84, types: 51, coercions: 0, joins: 0/0}
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T4908.$trModule4 :: Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T4908.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T4908.$trModule3 :: TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T4908.$trModule3 = GHC.Types.TrNameS T4908.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T4908.$trModule2 :: Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T4908.$trModule2 = "T4908"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T4908.$trModule1 :: TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T4908.$trModule1 = GHC.Types.TrNameS T4908.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T4908.$trModule :: Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T4908.$trModule
   = GHC.Types.Module T4908.$trModule3 T4908.$trModule1
 
+-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
+T4908.f1 :: Int
+[GblId,
+ Caf=NoCafRefs,
+ Str=tm(t),
+ Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
+         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
+T4908.f1 = GHC.Types.I# 1#
+
 Rec {
--- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
-T4908.f_$s$wf [Occ=LoopBreaker] :: Int -> Int# -> Int# -> Bool
-[GblId, Arity=3, Caf=NoCafRefs, Str=<L,A><L,1*U><S,1*U>]
+-- RHS size: {terms: 24, types: 8, coercions: 0, joins: 0/0}
+T4908.f_$s$wf [Occ=LoopBreaker] :: Int -> Int# -> Int# -> (# #)
+[GblId, Arity=3, Str=<L,A><L,1*U><S,1*U>m()]
 T4908.f_$s$wf
   = \ (sc :: Int) (sc1 :: Int#) (sc2 :: Int#) ->
       case sc2 of ds {
         __DEFAULT ->
           case sc1 of ds1 {
-            __DEFAULT -> T4908.f_$s$wf sc ds1 (-# ds 1#);
-            0# -> GHC.Types.True
+            __DEFAULT ->
+              case - @ Int GHC.Num.$fNumInt (GHC.Types.I# ds) T4908.f1 of
+              { I# ww1 ->
+              T4908.f_$s$wf sc ds1 ww1
+              };
+            0# -> GHC.Prim.(##)
           };
-        0# -> GHC.Types.True
+        0# -> GHC.Prim.(##)
       }
 end Rec }
 
--- RHS size: {terms: 24, types: 13, coercions: 0, joins: 0/0}
-T4908.$wf [InlPrag=NOUSERINLINE[0]] :: Int# -> (Int, Int) -> Bool
+-- RHS size: {terms: 29, types: 16, coercions: 0, joins: 0/0}
+T4908.$wf [InlPrag=NOUSERINLINE[0]] :: Int# -> (Int, Int) -> (# #)
 [GblId,
  Arity=2,
- Caf=NoCafRefs,
- Str=<S,1*U><L,1*U(A,1*U(1*U))>,
+ Str=<S,1*U><L,1*U(A,1*U(1*U))>m(),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
-         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 20] 101 20}]
+         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 20] 160 20}]
 T4908.$wf
   = \ (ww :: Int#) (w :: (Int, Int)) ->
       case ww of ds {
         __DEFAULT ->
           case w of { (a, b) ->
           case b of { I# ds1 ->
           case ds1 of ds2 {
-            __DEFAULT -> T4908.f_$s$wf a ds2 (-# ds 1#);
-            0# -> GHC.Types.True
+            __DEFAULT ->
+              case - @ Int GHC.Num.$fNumInt (GHC.Types.I# ds) T4908.f1 of
+              { I# ww2 ->
+              T4908.f_$s$wf a ds2 ww2
+              };
+            0# -> GHC.Prim.(##)
           }
           }
           };
-        0# -> GHC.Types.True
+        0# -> GHC.Prim.(##)
       }
 
--- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
+-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
 f [InlPrag=NOUSERINLINE[0]] :: Int -> (Int, Int) -> Bool
 [GblId,
  Arity=2,
- Caf=NoCafRefs,
- Str=<S(S),1*U(1*U)><L,1*U(A,1*U(1*U))>,
+ Str=<S(S),1*U(1*U)><L,1*U(A,1*U(1*U))>m2,
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
          Tmpl= \ (w [Occ=Once!] :: Int) (w1 [Occ=Once] :: (Int, Int)) ->
-                 case w of { I# ww1 [Occ=Once] -> T4908.$wf ww1 w1 }}]
+                 case w of { I# ww1 [Occ=Once] ->
+                 case T4908.$wf ww1 w1 of { (# #) -> GHC.Types.True }
+                 }}]
 f = \ (w :: Int) (w1 :: (Int, Int)) ->
-      case w of { I# ww1 -> T4908.$wf ww1 w1 }
+      case w of { I# ww1 ->
+      case T4908.$wf ww1 w1 of { (# #) -> GHC.Types.True }
+      }
 
 
 ------ Local rules for imported ids --------
diff --git a/testsuite/tests/simplCore/should_compile/T4918.stdout b/testsuite/tests/simplCore/should_compile/T4918.stdout
--- a/testsuite/tests/simplCore/should_compile/T4918.stdout
+++ b/testsuite/tests/simplCore/should_compile/T4918.stdout
@@ -1,2 +1,2 @@
-  {- HasNoCafRefs, Strictness: m, Unfolding: (C# 'p'#) -}
-  {- HasNoCafRefs, Strictness: m, Unfolding: (C# 'q'#) -}
+  {- HasNoCafRefs, Strictness: tm(t), Unfolding: (C# 'p'#) -}
+  {- HasNoCafRefs, Strictness: tm(t), Unfolding: (C# 'q'#) -}
diff --git a/testsuite/tests/simplCore/should_compile/T4930.stderr b/testsuite/tests/simplCore/should_compile/T4930.stderr
--- a/testsuite/tests/simplCore/should_compile/T4930.stderr
+++ b/testsuite/tests/simplCore/should_compile/T4930.stderr
@@ -7,41 +7,43 @@
 T4930.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T4930.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T4930.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T4930.$trModule3 = GHC.Types.TrNameS T4930.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T4930.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T4930.$trModule2 = "T4930"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T4930.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T4930.$trModule1 = GHC.Types.TrNameS T4930.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T4930.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T4930.$trModule
@@ -65,7 +67,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
diff --git a/testsuite/tests/simplCore/should_compile/T7360.stderr b/testsuite/tests/simplCore/should_compile/T7360.stderr
--- a/testsuite/tests/simplCore/should_compile/T7360.stderr
+++ b/testsuite/tests/simplCore/should_compile/T7360.stderr
@@ -8,10 +8,10 @@
 [GblId[DataConWrapper],
  Arity=1,
  Caf=NoCafRefs,
- Str=<S,U>m3,
+ Str=<S,U>,
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
-         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
+         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
          Tmpl= \ (dt [Occ=Once!] :: Int) ->
                  case dt of { GHC.Types.I# dt [Occ=Once] -> T7360.Foo3 dt }}]
 T7360.$WFoo3
@@ -23,7 +23,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S,1*U>,
+ Str=<S,1*U>m(),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
@@ -42,16 +42,16 @@
 T7360.fun4 :: Int
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.fun4 = GHC.Types.I# 0#
 
 -- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
 fun2 :: forall a. [a] -> ((), Int)
 [GblId,
  Arity=1,
- Str=<L,1*U>m,
+ Str=<L,1*U>tm(,m(t)),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
@@ -79,75 +79,78 @@
 T7360.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T7360.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$trModule3 = GHC.Types.TrNameS T7360.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T7360.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T7360.$trModule2 = "T7360"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$trModule1 = GHC.Types.TrNameS T7360.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T7360.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 T7360.$trModule
   = GHC.Types.Module T7360.$trModule3 T7360.$trModule1
 
 -- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
 $krep :: GHC.Types.KindRep
-[GblId, Caf=NoCafRefs, Str=m1]
+[GblId, Caf=NoCafRefs, Str=tm1]
 $krep
   = GHC.Types.KindRepTyConApp
       GHC.Types.$tcInt (GHC.Types.[] @ GHC.Types.KindRep)
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T7360.$tcFoo2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 T7360.$tcFoo2 = "Foo"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$tcFoo1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$tcFoo1 = GHC.Types.TrNameS T7360.$tcFoo2
 
 -- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
 T7360.$tcFoo :: GHC.Types.TyCon
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t,t,tm(tm1,tm1),tm1,t,tm5),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
 T7360.$tcFoo
@@ -161,33 +164,34 @@
 
 -- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
 T7360.$tc'Foo4 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
-[GblId, Caf=NoCafRefs, Str=m1]
+[GblId, Caf=NoCafRefs, Str=tm1]
 T7360.$tc'Foo4
   = GHC.Types.KindRepTyConApp
       T7360.$tcFoo (GHC.Types.[] @ GHC.Types.KindRep)
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo6 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T7360.$tc'Foo6 = "'Foo1"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo5 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$tc'Foo5 = GHC.Types.TrNameS T7360.$tc'Foo6
 
 -- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo1 :: GHC.Types.TyCon
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t,t,tm(tm1,tm1),tm1,t,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
 T7360.$tc'Foo1
@@ -203,24 +207,25 @@
 T7360.$tc'Foo8 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T7360.$tc'Foo8 = "'Foo2"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo7 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$tc'Foo7 = GHC.Types.TrNameS T7360.$tc'Foo8
 
 -- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo2 :: GHC.Types.TyCon
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t,t,tm(tm1,tm1),tm1,t,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
 T7360.$tc'Foo2
@@ -234,31 +239,32 @@
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo9 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
-[GblId, Caf=NoCafRefs, Str=m4]
+[GblId, Caf=NoCafRefs, Str=tm4]
 T7360.$tc'Foo9 = GHC.Types.KindRepFun $krep T7360.$tc'Foo4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo11 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 T7360.$tc'Foo11 = "'Foo3"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo10 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 T7360.$tc'Foo10 = GHC.Types.TrNameS T7360.$tc'Foo11
 
 -- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
 T7360.$tc'Foo3 :: GHC.Types.TyCon
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t,t,tm(tm1,tm1),tm1,t,tm4),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
 T7360.$tc'Foo3
diff --git a/testsuite/tests/simplCore/should_compile/noinline01.stderr b/testsuite/tests/simplCore/should_compile/noinline01.stderr
--- a/testsuite/tests/simplCore/should_compile/noinline01.stderr
+++ b/testsuite/tests/simplCore/should_compile/noinline01.stderr
@@ -2,64 +2,64 @@
 ==================== Pre unarise: ====================
 Noinline01.f [InlPrag=INLINE (sat-args=1)]
   :: forall p. p -> GHC.Types.Bool
-[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
+[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>tm2, Unf=OtherCon []] =
     [] \r [eta] GHC.Types.True [];
 
 Noinline01.g :: GHC.Types.Bool
 [GblId] =
     [] \u [] Noinline01.f GHC.Types.False;
 
 Noinline01.$trModule4 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []] =
     "main"#;
 
 Noinline01.$trModule3 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []] =
     NO_CCS GHC.Types.TrNameS! [Noinline01.$trModule4];
 
 Noinline01.$trModule2 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []] =
     "Noinline01"#;
 
 Noinline01.$trModule1 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []] =
     NO_CCS GHC.Types.TrNameS! [Noinline01.$trModule2];
 
 Noinline01.$trModule :: GHC.Types.Module
-[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm(tm1,tm1), Unf=OtherCon []] =
     NO_CCS GHC.Types.Module! [Noinline01.$trModule3
                               Noinline01.$trModule1];
 
 
 
 ==================== STG syntax: ====================
 Noinline01.f [InlPrag=INLINE (sat-args=1)]
   :: forall p. p -> GHC.Types.Bool
-[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
+[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>tm2, Unf=OtherCon []] =
     [] \r [eta] GHC.Types.True [];
 
 Noinline01.g :: GHC.Types.Bool
 [GblId] =
     [] \u [] Noinline01.f GHC.Types.False;
 
 Noinline01.$trModule4 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []] =
     "main"#;
 
 Noinline01.$trModule3 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []] =
     NO_CCS GHC.Types.TrNameS! [Noinline01.$trModule4];
 
 Noinline01.$trModule2 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []] =
     "Noinline01"#;
 
 Noinline01.$trModule1 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []] =
     NO_CCS GHC.Types.TrNameS! [Noinline01.$trModule2];
 
 Noinline01.$trModule :: GHC.Types.Module
-[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
+[GblId, Caf=NoCafRefs, Str=tm(tm1,tm1), Unf=OtherCon []] =
     NO_CCS GHC.Types.Module! [Noinline01.$trModule3
                               Noinline01.$trModule1];
 
diff --git a/testsuite/tests/simplCore/should_compile/par01.stderr b/testsuite/tests/simplCore/should_compile/par01.stderr
--- a/testsuite/tests/simplCore/should_compile/par01.stderr
+++ b/testsuite/tests/simplCore/should_compile/par01.stderr
@@ -16,27 +16,27 @@
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 Par01.$trModule4 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []]
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []]
 Par01.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 Par01.$trModule3 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []]
 Par01.$trModule3 = GHC.Types.TrNameS Par01.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 Par01.$trModule2 :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs, Unf=OtherCon []]
+[GblId, Caf=NoCafRefs, Str=t, Unf=OtherCon []]
 Par01.$trModule2 = "Par01"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 Par01.$trModule1 :: GHC.Types.TrName
-[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
+[GblId, Caf=NoCafRefs, Str=tm1, Unf=OtherCon []]
 Par01.$trModule1 = GHC.Types.TrNameS Par01.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 Par01.$trModule :: GHC.Types.Module
-[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
+[GblId, Caf=NoCafRefs, Str=tm(tm1,tm1), Unf=OtherCon []]
 Par01.$trModule =
   GHC.Types.Module Par01.$trModule3 Par01.$trModule1
 
diff --git a/testsuite/tests/simplCore/should_compile/spec-inline.stderr b/testsuite/tests/simplCore/should_compile/spec-inline.stderr
--- a/testsuite/tests/simplCore/should_compile/spec-inline.stderr
+++ b/testsuite/tests/simplCore/should_compile/spec-inline.stderr
@@ -7,49 +7,51 @@
 Roman.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
 Roman.$trModule4 = "main"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 Roman.$trModule3 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 Roman.$trModule3 = GHC.Types.TrNameS Roman.$trModule4
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 Roman.$trModule2 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
+ Str=t,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
 Roman.$trModule2 = "Roman"#
 
 -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 Roman.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
+ Str=tm1,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 Roman.$trModule1 = GHC.Types.TrNameS Roman.$trModule2
 
 -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 Roman.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
 Roman.$trModule
   = GHC.Types.Module Roman.$trModule3 Roman.$trModule1
 
 -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
 lvl :: GHC.Prim.Addr#
-[GblId, Caf=NoCafRefs]
+[GblId, Caf=NoCafRefs, Str=t]
 lvl = "spec-inline.hs:(19,5)-(29,25)|function go"#
 
 -- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
@@ -139,7 +141,7 @@
   :: Maybe Int -> Maybe Int -> Int
 [GblId,
  Arity=2,
- Str=<S,1*U><S,1*U>m,
+ Str=<S,1*U><S,1*U>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
@@ -153,16 +155,16 @@
 Roman.foo2 :: Int
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(t),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 Roman.foo2 = GHC.Types.I# 6#
 
 -- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
 Roman.foo1 :: Maybe Int
 [GblId,
  Caf=NoCafRefs,
- Str=m2,
+ Str=tm2,
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
 Roman.foo1 = GHC.Base.Just @ Int Roman.foo2
@@ -172,7 +174,7 @@
 [GblId,
  Arity=1,
  Caf=NoCafRefs,
- Str=<S(S),1*U(U)>m,
+ Str=<S(S),1*U(U)>m(t),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
          WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
diff --git a/testsuite/tests/simplStg/should_run/T9291.hs b/testsuite/tests/simplStg/should_run/T9291.hs
--- a/testsuite/tests/simplStg/should_run/T9291.hs
+++ b/testsuite/tests/simplStg/should_run/T9291.hs
@@ -7,8 +7,9 @@
 foo _ = Left True
 {-# NOINLINE foo #-}
 
-bar :: a -> (Either Int a, Either Bool a)
-bar x = (Right x, Right x)
+bar :: a -> [(Either Int a, Either Bool a)]
+-- The use of a list prevents CPR.
+bar x = [(Right x, Right x)]
 {-# NOINLINE bar #-}
 
 nested :: Either Int (Either Int a) -> Either Bool (Either Bool a)
@@ -37,11 +38,11 @@
 {-# NOINLINE rec2 #-}
 
 test x = do
-    let (r1,r2) = bar x
+    let [(r1,r2)] = bar x
     (same $! r1) $! r2
     let r3 = foo r1
     (same $! r1) $! r3
-    let (r4,_) = bar r1
+    let [(r4,_)] = bar r1
     let r5 = nested r4
     (same $! r4) $! r5
     let (T _ r6 r7) = rec1 x
diff --git a/testsuite/tests/stranal/should_compile/T10694.stderr b/testsuite/tests/stranal/should_compile/T10694.stderr
--- a/testsuite/tests/stranal/should_compile/T10694.stderr
+++ b/testsuite/tests/stranal/should_compile/T10694.stderr
@@ -1,75 +1,93 @@
 
 ==================== Tidy Core ====================
-Result size of Tidy Core = {terms: 70, types: 63, coercions: 0}
+Result size of Tidy Core = {terms: 74, types: 65, coercions: 0, joins: 0/4}
 
--- RHS size: {terms: 39, types: 25, coercions: 0}
+-- RHS size: {terms: 39, types: 25, coercions: 0, joins: 0/4}
 T10694.$wpm [InlPrag=NOINLINE] :: Int -> Int -> (# Int, Int #)
-[GblId, Arity=2, Str=<L,U(U)><L,U(U)>]
-T10694.$wpm =
-  \ (w_sVU :: Int) (w1_sVV :: Int) ->
-    let {
-      l_sUQ :: Int
-      [LclId]
-      l_sUQ = case w_sVU of { GHC.Types.I# x_aUi -> case w1_sVV of { GHC.Types.I# y_aUm -> GHC.Types.I# (GHC.Prim.+# x_aUi y_aUm) } } } in
-    let {
-      l1_sUS :: Int
-      [LclId]
-      l1_sUS = case w_sVU of { GHC.Types.I# x_aUs -> case w1_sVV of { GHC.Types.I# y_aUw -> GHC.Types.I# (GHC.Prim.-# x_aUs y_aUw) } } } in
-    let {
-      l2_sUR :: [Int]
-      [LclId, Unf=OtherCon []]
-      l2_sUR = GHC.Types.: @ Int l1_sUS (GHC.Types.[] @ Int) } in
-    let {
-      l3_sUH :: [Int]
-      [LclId, Unf=OtherCon []]
-      l3_sUH = GHC.Types.: @ Int l_sUQ l2_sUR } in
-    (# GHC.List.$w!! @ Int l3_sUH 0#, GHC.List.$w!! @ Int l3_sUH 1# #)
+[GblId, Arity=2, Str=<L,U(U)><L,U(U)>tm(,)]
+T10694.$wpm
+  = \ (w_s1pY :: Int) (w1_s1pZ :: Int) ->
+      let {
+        l_s1oV :: Int
+        [LclId]
+        l_s1oV
+          = case w_s1pY of { GHC.Types.I# x_a1ol -> case w1_s1pZ of { GHC.Types.I# y_a1op -> GHC.Types.I# (GHC.Prim.+# x_a1ol y_a1op) } } } in
+      let {
+        l1_s1oX :: Int
+        [LclId]
+        l1_s1oX
+          = case w_s1pY of { GHC.Types.I# x_a1ov -> case w1_s1pZ of { GHC.Types.I# y_a1oz -> GHC.Types.I# (GHC.Prim.-# x_a1ov y_a1oz) } } } in
+      let {
+        l2_s1oW :: [Int]
+        [LclId, Unf=OtherCon []]
+        l2_s1oW = GHC.Types.: @ Int l1_s1oX (GHC.Types.[] @ Int) } in
+      let {
+        l3_s1oM :: [Int]
+        [LclId, Unf=OtherCon []]
+        l3_s1oM = GHC.Types.: @ Int l_s1oV l2_s1oW } in
+      (# GHC.List.$w!! @ Int l3_s1oM 0#, GHC.List.$w!! @ Int l3_s1oM 1# #)
 
--- RHS size: {terms: 10, types: 11, coercions: 0}
+-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
 pm [InlPrag=INLINE[0]] :: Int -> Int -> (Int, Int)
 [GblId,
  Arity=2,
- Str=<L,U(U)><L,U(U)>m,
+ Str=<L,U(U)><L,U(U)>tm(,),
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
-         Tmpl= \ (w_sVU [Occ=Once] :: Int) (w1_sVV [Occ=Once] :: Int) ->
-                 case T10694.$wpm w_sVU w1_sVV of { (# ww1_sW0 [Occ=Once], ww2_sW1 [Occ=Once] #) -> (ww1_sW0, ww2_sW1) }}]
-pm = \ (w_sVU :: Int) (w1_sVV :: Int) -> case T10694.$wpm w_sVU w1_sVV of { (# ww1_sW0, ww2_sW1 #) -> (ww1_sW0, ww2_sW1) }
+         Tmpl= \ (w_s1pY [Occ=Once] :: Int) (w1_s1pZ [Occ=Once] :: Int) ->
+                 case T10694.$wpm w_s1pY w1_s1pZ of { (# ww1_s1q2 [Occ=Once], ww2_s1q3 [Occ=Once] #) -> (ww1_s1q2, ww2_s1q3) }}]
+pm = \ (w_s1pY :: Int) (w1_s1pZ :: Int) -> case T10694.$wpm w_s1pY w1_s1pZ of { (# ww1_s1q2, ww2_s1q3 #) -> (ww1_s1q2, ww2_s1q3) }
 
--- RHS size: {terms: 8, types: 9, coercions: 0}
+-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
 m :: Int -> Int -> Int
 [GblId,
  Arity=2,
  Str=<L,U(U)><L,U(U)>,
  Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True,
          Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
-         Tmpl= \ (x_aCT [Occ=Once] :: Int) (y_aCU [Occ=Once] :: Int) ->
-                 case pm x_aCT y_aCU of { (_ [Occ=Dead], mr_aCW [Occ=Once]) -> mr_aCW }}]
-m = \ (x_aCT :: Int) (y_aCU :: Int) -> case T10694.$wpm x_aCT y_aCU of { (# ww1_sW0, ww2_sW1 #) -> ww2_sW1 }
+         Tmpl= \ (x_aXR [Occ=Once] :: Int) (y_aXS [Occ=Once] :: Int) ->
+                 case pm x_aXR y_aXS of { (_ [Occ=Dead], mr_aXU [Occ=Once]) -> mr_aXU }}]
+m = \ (x_aXR :: Int) (y_aXS :: Int) -> case T10694.$wpm x_aXR y_aXS of { (# ww1_s1q2, ww2_s1q3 #) -> ww2_s1q3 }
 
--- RHS size: {terms: 2, types: 0, coercions: 0}
-T10694.$trModule2 :: GHC.Types.TrName
+-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
+T10694.$trModule4 :: GHC.Prim.Addr#
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
- Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
-T10694.$trModule2 = GHC.Types.TrNameS "main"#
+ Str=t,
+ Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
+T10694.$trModule4 = "main"#
 
--- RHS size: {terms: 2, types: 0, coercions: 0}
+-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
+T10694.$trModule3 :: GHC.Types.TrName
+[GblId,
+ Caf=NoCafRefs,
+ Str=tm1,
+ Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
+T10694.$trModule3 = GHC.Types.TrNameS T10694.$trModule4
+
+-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
+T10694.$trModule2 :: GHC.Prim.Addr#
+[GblId,
+ Caf=NoCafRefs,
+ Str=t,
+ Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
+T10694.$trModule2 = "T10694"#
+
+-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
 T10694.$trModule1 :: GHC.Types.TrName
 [GblId,
  Caf=NoCafRefs,
- Str=m1,
- Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 20}]
-T10694.$trModule1 = GHC.Types.TrNameS "T10694"#
+ Str=tm1,
+ Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
+T10694.$trModule1 = GHC.Types.TrNameS T10694.$trModule2
 
--- RHS size: {terms: 3, types: 0, coercions: 0}
+-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
 T10694.$trModule :: GHC.Types.Module
 [GblId,
  Caf=NoCafRefs,
- Str=m,
+ Str=tm(tm1,tm1),
  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True, WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
-T10694.$trModule = GHC.Types.Module T10694.$trModule2 T10694.$trModule1
+T10694.$trModule = GHC.Types.Module T10694.$trModule3 T10694.$trModule1
 
 
 
diff --git a/testsuite/tests/stranal/should_run/Stream.hs b/testsuite/tests/stranal/should_run/Stream.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/should_run/Stream.hs
@@ -0,0 +1,13 @@
+-- Adapted from symalg/RealM.hs's treeFrom
+
+data Stream a = Stream a (Stream a)
+
+-- This must not get a CPR signature that allows for nested cpr,
+-- as it would make the worker call itself before producing the
+-- Stream constructor.
+
+forever :: a -> Stream a
+forever x = Stream x (forever x)
+
+main :: IO ()
+main = forever () `seq` return ()
diff --git a/testsuite/tests/stranal/should_run/all.T b/testsuite/tests/stranal/should_run/all.T
--- a/testsuite/tests/stranal/should_run/all.T
+++ b/testsuite/tests/stranal/should_run/all.T
@@ -17,3 +17,4 @@
 test('T13380', [expect_broken(13380), exit_code(1)], compile_and_run, [''])
 test('T14290', normal, compile_and_run, [''])
 test('T14285', normal, multimod_compile_and_run, ['T14285', ''])
+test('Stream', extra_run_opts('+RTS -M1M -RTS'), compile_and_run, [''])
diff --git a/testsuite/tests/stranal/sigs/AnonLambda.hs b/testsuite/tests/stranal/sigs/AnonLambda.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/AnonLambda.hs
@@ -0,0 +1,11 @@
+module AnonLambda where
+
+g :: Int -> Bool
+{-# NOINLINE g #-}
+g = (==0)
+
+-- This test ensures that the CPR property of the anonymous lambda
+-- Does not escape to f (which has arity 1)
+
+f = \x -> if g x then \y -> x + y + 1
+                 else \y -> x + y + 2
diff --git a/testsuite/tests/stranal/sigs/AnonLambda.stderr b/testsuite/tests/stranal/sigs/AnonLambda.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/AnonLambda.stderr
@@ -0,0 +1,14 @@
+
+==================== Strictness signatures ====================
+AnonLambda.$trModule: tm(tm1,tm1)
+AnonLambda.f: <S(S),U(U)>
+AnonLambda.g: <S(S),1*U(1*U)>
+
+
+
+==================== Strictness signatures ====================
+AnonLambda.$trModule: tm(tm1,tm1)
+AnonLambda.f: <S(S),1*U(U)>
+AnonLambda.g: <S(S),1*U(1*U)>
+
+
diff --git a/testsuite/tests/stranal/sigs/BottomFromInnerLambda.stderr b/testsuite/tests/stranal/sigs/BottomFromInnerLambda.stderr
--- a/testsuite/tests/stranal/sigs/BottomFromInnerLambda.stderr
+++ b/testsuite/tests/stranal/sigs/BottomFromInnerLambda.stderr
@@ -1,14 +1,14 @@
 
 ==================== Strictness signatures ====================
-BottomFromInnerLambda.$trModule: m
-BottomFromInnerLambda.expensive: <S(S),1*U(U)>m
+BottomFromInnerLambda.$trModule: tm(tm1,tm1)
+BottomFromInnerLambda.expensive: <S(S),1*U(U)>m(t)
 BottomFromInnerLambda.f: <S(S),1*U(U)>
 
 
 
 ==================== Strictness signatures ====================
-BottomFromInnerLambda.$trModule: m
-BottomFromInnerLambda.expensive: <S(S),1*U(1*U)>m
+BottomFromInnerLambda.$trModule: tm(tm1,tm1)
+BottomFromInnerLambda.expensive: <S(S),1*U(1*U)>m(t)
 BottomFromInnerLambda.f: <S(S),1*U(1*U)>
 
 
diff --git a/testsuite/tests/stranal/sigs/CaseBinderCPR.hs b/testsuite/tests/stranal/sigs/CaseBinderCPR.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/CaseBinderCPR.hs
@@ -0,0 +1,15 @@
+module CaseBinderCPR where
+
+-- This example, taken from nofib's transform (and heavily reduced) ensures that
+-- CPR information is added to a case binder
+
+f_list_cmp::(t1 -> t1 -> Int) -> [t1] -> [t1] -> Int;
+f_list_cmp a_cmp [] []= 0
+f_list_cmp a_cmp [] a_ys= -1
+f_list_cmp a_cmp a_xs []= 1
+f_list_cmp a_cmp (a_x:a_xs) (a_y:a_ys)=
+    if r_order == 0
+    then f_list_cmp a_cmp a_xs a_ys
+    else r_order
+  where
+    r_order = a_cmp a_x a_y
diff --git a/testsuite/tests/stranal/sigs/CaseBinderCPR.stderr b/testsuite/tests/stranal/sigs/CaseBinderCPR.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/CaseBinderCPR.stderr
@@ -0,0 +1,12 @@
+
+==================== Strictness signatures ====================
+CaseBinderCPR.$trModule: tm(tm1,tm1)
+CaseBinderCPR.f_list_cmp: <L,C(C1(U(U)))><S,1*U><S,1*U>m()
+
+
+
+==================== Strictness signatures ====================
+CaseBinderCPR.$trModule: tm(tm1,tm1)
+CaseBinderCPR.f_list_cmp: <L,C(C1(U(U)))><S,1*U><S,1*U>m(t)
+
+
diff --git a/testsuite/tests/stranal/sigs/DmdAnalGADTs.stderr b/testsuite/tests/stranal/sigs/DmdAnalGADTs.stderr
--- a/testsuite/tests/stranal/sigs/DmdAnalGADTs.stderr
+++ b/testsuite/tests/stranal/sigs/DmdAnalGADTs.stderr
@@ -1,28 +1,28 @@
 
 ==================== Strictness signatures ====================
-DmdAnalGADTs.$tc'A: m
-DmdAnalGADTs.$tc'B: m
-DmdAnalGADTs.$tcD: m
-DmdAnalGADTs.$trModule: m
+DmdAnalGADTs.$tc'A: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+DmdAnalGADTs.$tc'B: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+DmdAnalGADTs.$tcD: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+DmdAnalGADTs.$trModule: tm(tm1,tm1)
 DmdAnalGADTs.diverges: b
 DmdAnalGADTs.f: <S,1*U>
-DmdAnalGADTs.f': <S,1*U>m
+DmdAnalGADTs.f': <S,1*U>m(t)
 DmdAnalGADTs.g: <S,1*U>
-DmdAnalGADTs.hasCPR: m
-DmdAnalGADTs.hasStrSig: <S,1*U(U)>m
+DmdAnalGADTs.hasCPR: tm(t)
+DmdAnalGADTs.hasStrSig: <S,1*U(U)>m()
 
 
 
 ==================== Strictness signatures ====================
-DmdAnalGADTs.$tc'A: m
-DmdAnalGADTs.$tc'B: m
-DmdAnalGADTs.$tcD: m
-DmdAnalGADTs.$trModule: m
+DmdAnalGADTs.$tc'A: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+DmdAnalGADTs.$tc'B: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+DmdAnalGADTs.$tcD: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+DmdAnalGADTs.$trModule: tm(tm1,tm1)
 DmdAnalGADTs.diverges: b
 DmdAnalGADTs.f: <S,1*U>
-DmdAnalGADTs.f': <S,1*U>m
+DmdAnalGADTs.f': <S,1*U>m(t)
 DmdAnalGADTs.g: <S,1*U>
-DmdAnalGADTs.hasCPR: m
-DmdAnalGADTs.hasStrSig: <S,1*U(U)>m
+DmdAnalGADTs.hasCPR: tm(t)
+DmdAnalGADTs.hasStrSig: <S,1*U(U)>m()
 
 
diff --git a/testsuite/tests/stranal/sigs/FacState.stderr b/testsuite/tests/stranal/sigs/FacState.stderr
--- a/testsuite/tests/stranal/sigs/FacState.stderr
+++ b/testsuite/tests/stranal/sigs/FacState.stderr
@@ -1,5 +1,12 @@
 
 ==================== Strictness signatures ====================
-FacState.fac: <S,1*U(U)><L,U>dm1(d,tm1(d))
+FacState.$trModule: tm(tm1,tm1)
+FacState.fac: <S(S),1*U(U)><L,U>m(,tm(t))
+
+
+
+==================== Strictness signatures ====================
+FacState.$trModule: tm(tm1,tm1)
+FacState.fac: <S(S),1*U(U)><L,U>m(,tm(t))
 
 
diff --git a/testsuite/tests/stranal/sigs/HyperStrUse.stderr b/testsuite/tests/stranal/sigs/HyperStrUse.stderr
--- a/testsuite/tests/stranal/sigs/HyperStrUse.stderr
+++ b/testsuite/tests/stranal/sigs/HyperStrUse.stderr
@@ -1,12 +1,12 @@
 
 ==================== Strictness signatures ====================
-HyperStrUse.$trModule: m
-HyperStrUse.f: <S(S(S)L),1*U(1*U(U),A)><S,1*U>m
+HyperStrUse.$trModule: tm(tm1,tm1)
+HyperStrUse.f: <S(S(S)L),1*U(1*U(U),A)><S,1*U>m(t)
 
 
 
 ==================== Strictness signatures ====================
-HyperStrUse.$trModule: m
-HyperStrUse.f: <S(S(S)L),1*U(1*U(U),A)><S,1*U>m
+HyperStrUse.$trModule: tm(tm1,tm1)
+HyperStrUse.f: <S(S(S)L),1*U(1*U(U),A)><S,1*U>m(t)
 
 
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPR.hs b/testsuite/tests/stranal/sigs/InfiniteCPR.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPR.hs
@@ -0,0 +1,9 @@
+module InfiniteCPR where
+
+data Rec1 = Foo Rec2 Rec2
+data Rec2 = Bar Rec1 Rec1
+
+f a =
+    let x = Foo a y
+        y = Bar x x
+    in x
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPR.stderr b/testsuite/tests/stranal/sigs/InfiniteCPR.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPR.stderr
@@ -0,0 +1,20 @@
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+InfiniteCPR.$tc'Foo: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+InfiniteCPR.$tcRec1: tm(t,t,tm(tm1,tm1),tm1,t,tm5)
+InfiniteCPR.$tcRec2: tm(t,t,tm(tm1,tm1),tm1,t,tm5)
+InfiniteCPR.$trModule: tm(tm1,tm1)
+InfiniteCPR.f: <L,U>m(,tm(m(,tm(,)),m(,tm(,))))
+
+
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+InfiniteCPR.$tc'Foo: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+InfiniteCPR.$tcRec1: tm(t,t,tm(tm1,tm1),tm1,t,tm5)
+InfiniteCPR.$tcRec2: tm(t,t,tm(tm1,tm1),tm1,t,tm5)
+InfiniteCPR.$trModule: tm(tm1,tm1)
+InfiniteCPR.f: <L,U>m(,tm(m(,tm(,)),m(,tm(,))))
+
+
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.hs b/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.hs
@@ -0,0 +1,11 @@
+{-# OPTIONS_GHC -fcpr-depth=0 #-}
+
+module InfiniteCPR where
+
+data Rec1 = Foo Rec2 Rec2
+data Rec2 = Bar Rec1 Rec1
+
+f a =
+    let x = Foo a y
+        y = Bar x x
+    in x
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.stderr b/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPRDepth0.stderr
@@ -0,0 +1,20 @@
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar:
+InfiniteCPR.$tc'Foo:
+InfiniteCPR.$tcRec1:
+InfiniteCPR.$tcRec2:
+InfiniteCPR.$trModule:
+InfiniteCPR.f: <L,U>
+
+
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar:
+InfiniteCPR.$tc'Foo:
+InfiniteCPR.$tcRec1:
+InfiniteCPR.$tcRec2:
+InfiniteCPR.$trModule:
+InfiniteCPR.f: <L,U>
+
+
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.hs b/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.hs
@@ -0,0 +1,11 @@
+{-# OPTIONS_GHC -fcpr-depth=1 #-}
+
+module InfiniteCPR where
+
+data Rec1 = Foo Rec2 Rec2
+data Rec2 = Bar Rec1 Rec1
+
+f a =
+    let x = Foo a y
+        y = Bar x x
+    in x
diff --git a/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.stderr b/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/InfiniteCPRDepth1.stderr
@@ -0,0 +1,20 @@
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar: tm(,,,,,)
+InfiniteCPR.$tc'Foo: tm(,,,,,)
+InfiniteCPR.$tcRec1: tm(,,,,,)
+InfiniteCPR.$tcRec2: tm(,,,,,)
+InfiniteCPR.$trModule: tm(,)
+InfiniteCPR.f: <L,U>m(,)
+
+
+
+==================== Strictness signatures ====================
+InfiniteCPR.$tc'Bar: tm(,,,,,)
+InfiniteCPR.$tc'Foo: tm(,,,,,)
+InfiniteCPR.$tcRec1: tm(,,,,,)
+InfiniteCPR.$tcRec2: tm(,,,,,)
+InfiniteCPR.$trModule: tm(,)
+InfiniteCPR.f: <L,U>m(,)
+
+
diff --git a/testsuite/tests/stranal/sigs/StrAnalExample.stderr b/testsuite/tests/stranal/sigs/StrAnalExample.stderr
--- a/testsuite/tests/stranal/sigs/StrAnalExample.stderr
+++ b/testsuite/tests/stranal/sigs/StrAnalExample.stderr
@@ -1,12 +1,12 @@
 
 ==================== Strictness signatures ====================
-StrAnalExample.$trModule: m
+StrAnalExample.$trModule: tm(tm1,tm1)
 StrAnalExample.foo: <S,1*U>
 
 
 
 ==================== Strictness signatures ====================
-StrAnalExample.$trModule: m
+StrAnalExample.$trModule: tm(tm1,tm1)
 StrAnalExample.foo: <S,1*U>
 
 
diff --git a/testsuite/tests/stranal/sigs/StreamSig.hs b/testsuite/tests/stranal/sigs/StreamSig.hs
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/StreamSig.hs
@@ -0,0 +1,11 @@
+module StreamSig where
+-- Adapted from symalg/RealM.hs's treeFrom
+
+data Stream a = Stream a (Stream a)
+
+-- This must not get a CPR signature that allows for nested cpr,
+-- as it would make the worker call itself before producing the
+-- Stream constructor.
+
+forever :: a -> Stream a
+forever x = Stream x (forever x)
diff --git a/testsuite/tests/stranal/sigs/StreamSig.stderr b/testsuite/tests/stranal/sigs/StreamSig.stderr
new file mode 100644
--- /dev/null
+++ b/testsuite/tests/stranal/sigs/StreamSig.stderr
@@ -0,0 +1,16 @@
+
+==================== Strictness signatures ====================
+StreamSig.$tc'Stream: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+StreamSig.$tcStream: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+StreamSig.$trModule: tm(tm1,tm1)
+StreamSig.forever: <L,U>tm(,m(,m(,m(,))))
+
+
+
+==================== Strictness signatures ====================
+StreamSig.$tc'Stream: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+StreamSig.$tcStream: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+StreamSig.$trModule: tm(tm1,tm1)
+StreamSig.forever: <L,U>tm(,m(,m(,m(,))))
+
+
diff --git a/testsuite/tests/stranal/sigs/T12370.stderr b/testsuite/tests/stranal/sigs/T12370.stderr
--- a/testsuite/tests/stranal/sigs/T12370.stderr
+++ b/testsuite/tests/stranal/sigs/T12370.stderr
@@ -1,14 +1,14 @@
 
 ==================== Strictness signatures ====================
-T12370.$trModule: m
-T12370.bar: <S(S),1*U(U)><S(S),1*U(U)>m
-T12370.foo: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m
+T12370.$trModule: tm(tm1,tm1)
+T12370.bar: <S(S),1*U(U)><S(S),1*U(U)>m(t)
+T12370.foo: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m(t)
 
 
 
 ==================== Strictness signatures ====================
-T12370.$trModule: m
-T12370.bar: <S(S),1*U(U)><S(S),1*U(U)>m
-T12370.foo: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m
+T12370.$trModule: tm(tm1,tm1)
+T12370.bar: <S(S),1*U(U)><S(S),1*U(U)>m(t)
+T12370.foo: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>m(t)
 
 
diff --git a/testsuite/tests/stranal/sigs/T8569.stderr b/testsuite/tests/stranal/sigs/T8569.stderr
--- a/testsuite/tests/stranal/sigs/T8569.stderr
+++ b/testsuite/tests/stranal/sigs/T8569.stderr
@@ -1,18 +1,18 @@
 
 ==================== Strictness signatures ====================
-T8569.$tc'Rdata: m
-T8569.$tc'Rint: m
-T8569.$tcRep: m
-T8569.$trModule: m
+T8569.$tc'Rdata: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+T8569.$tc'Rint: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+T8569.$tcRep: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+T8569.$trModule: tm(tm1,tm1)
 T8569.addUp: <S,1*U><L,U>
 
 
 
 ==================== Strictness signatures ====================
-T8569.$tc'Rdata: m
-T8569.$tc'Rint: m
-T8569.$tcRep: m
-T8569.$trModule: m
+T8569.$tc'Rdata: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+T8569.$tc'Rint: tm(t,t,tm(tm1,tm1),tm1,t,tm1)
+T8569.$tcRep: tm(t,t,tm(tm1,tm1),tm1,t,tm4)
+T8569.$trModule: tm(tm1,tm1)
 T8569.addUp: <S,1*U><L,U>
 
 
diff --git a/testsuite/tests/stranal/sigs/T8598.stderr b/testsuite/tests/stranal/sigs/T8598.stderr
--- a/testsuite/tests/stranal/sigs/T8598.stderr
+++ b/testsuite/tests/stranal/sigs/T8598.stderr
@@ -1,12 +1,12 @@
 
 ==================== Strictness signatures ====================
-T8598.$trModule: m
-T8598.fun: <S(S),1*U(U)>m
+T8598.$trModule: tm(tm1,tm1)
+T8598.fun: <S(S),1*U(U)>m()
 
 
 
 ==================== Strictness signatures ====================
-T8598.$trModule: m
-T8598.fun: <S(S),1*U(U)>m
+T8598.$trModule: tm(tm1,tm1)
+T8598.fun: <S(S),1*U(U)>m(t)
 
 
diff --git a/testsuite/tests/stranal/sigs/UnsatFun.stderr b/testsuite/tests/stranal/sigs/UnsatFun.stderr
--- a/testsuite/tests/stranal/sigs/UnsatFun.stderr
+++ b/testsuite/tests/stranal/sigs/UnsatFun.stderr
@@ -1,24 +1,24 @@
 
 ==================== Strictness signatures ====================
-UnsatFun.$trModule: m
+UnsatFun.$trModule: tm(tm1,tm1)
 UnsatFun.f: <B,1*U(U)><B,A>x
 UnsatFun.g: <B,1*U(U)>x
 UnsatFun.g': <L,1*U(U)>
-UnsatFun.g3: <L,U(U)>m
+UnsatFun.g3: <L,U(U)>m(t)
 UnsatFun.h: <C(S),1*C1(U(U))>
 UnsatFun.h2: <S,1*U><L,1*C1(U(U))>
-UnsatFun.h3: <C(S),1*C1(U)>m
+UnsatFun.h3: <C(S),1*C1(U)>m(t)
 
 
 
 ==================== Strictness signatures ====================
-UnsatFun.$trModule: m
+UnsatFun.$trModule: tm(tm1,tm1)
 UnsatFun.f: <B,1*U(U)><B,A>x
 UnsatFun.g: <B,1*U(U)>x
 UnsatFun.g': <L,1*U(U)>
-UnsatFun.g3: <L,U(U)>m
+UnsatFun.g3: <L,U(U)>m(t)
 UnsatFun.h: <C(S),1*C1(U(U))>
 UnsatFun.h2: <S,1*U><L,1*C1(U(U))>
-UnsatFun.h3: <C(S),1*C1(U)>m
+UnsatFun.h3: <C(S),1*C1(U)>m(t)
 
 
diff --git a/testsuite/tests/stranal/sigs/all.T b/testsuite/tests/stranal/sigs/all.T
--- a/testsuite/tests/stranal/sigs/all.T
+++ b/testsuite/tests/stranal/sigs/all.T
@@ -11,8 +11,14 @@
 test('T8569', normal, compile, [''])
 test('HyperStrUse', normal, compile, [''])
 test('T8598', normal, compile, [''])
-test('FacState', expect_broken(1600), compile, [''])
+test('FacState', normal, compile, [''])
 test('UnsatFun', normal, compile, [''])
 test('BottomFromInnerLambda', normal, compile, [''])
 test('DmdAnalGADTs', normal, compile, [''])
 test('T12370', normal, compile, [''])
+test('CaseBinderCPR', normal, compile, [''])
+test('InfiniteCPR', normal, compile, [''])
+test('InfiniteCPRDepth0', normal, compile, [''])
+test('InfiniteCPRDepth1', normal, compile, [''])
+test('AnonLambda', normal, compile, [''])
+test('StreamSig', normal, compile, [''])

